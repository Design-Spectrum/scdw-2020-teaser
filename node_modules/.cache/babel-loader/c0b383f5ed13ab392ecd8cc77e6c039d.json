{"ast":null,"code":"import _assertThisInitialized from \"/Users/jinjaelee/Projects/scdw-2020-teaser/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _slicedToArray from \"/Users/jinjaelee/Projects/scdw-2020-teaser/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/jinjaelee/Projects/scdw-2020-teaser/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _get from \"/Users/jinjaelee/Projects/scdw-2020-teaser/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/jinjaelee/Projects/scdw-2020-teaser/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"/Users/jinjaelee/Projects/scdw-2020-teaser/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/jinjaelee/Projects/scdw-2020-teaser/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/jinjaelee/Projects/scdw-2020-teaser/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _wrapNativeSuper from \"/Users/jinjaelee/Projects/scdw-2020-teaser/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\nimport _asyncToGenerator from \"/Users/jinjaelee/Projects/scdw-2020-teaser/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _createForOfIteratorHelper from \"/Users/jinjaelee/Projects/scdw-2020-teaser/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/jinjaelee/Projects/scdw-2020-teaser/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _toConsumableArray from \"/Users/jinjaelee/Projects/scdw-2020-teaser/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { useLayoutEffect } from 'react-layout-effect';\nimport { each as _each, is, toArray, isAnimatedString, getFluidConfig, Globals, FluidValue, getFluidValue, flush, isEqual, noop, useForceUpdate, usePrev, useOnce, createInterpolator } from '@react-spring/shared';\nexport { FrameLoop, Globals, createInterpolator } from '@react-spring/shared';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { createContext, useContext, createElement, useRef, useState, useMemo as useMemo$1, useImperativeHandle, Fragment } from 'react';\nimport { getAnimated, AnimatedValue, getPayload, setAnimated, AnimatedArray, AnimatedString } from '@react-spring/animated';\nimport { createStringInterpolator, batchedUpdates, to as to$1, frameLoop, skipAnimation } from '@react-spring/shared/globals';\nimport { useMemoOne, useCallbackOne } from 'use-memo-one';\nimport { deprecateInterpolate } from '@react-spring/shared/deprecations';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport { createStringInterpolator as createStringInterpolator$1 } from '@react-spring/shared/stringInterpolation';\nexport * from '@react-spring/shared/types';\n/** API\n *  useChain(references, timeSteps, timeFrame)\n */\n\nfunction useChain(refs, timeSteps) {\n  var timeFrame = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n  useLayoutEffect(function () {\n    if (timeSteps) {\n      var prevDelay = 0;\n\n      _each(refs, function (ref, i) {\n        if (!ref.current) return;\n        var controllers = ref.current.controllers;\n\n        if (controllers.length) {\n          var delay = timeFrame * timeSteps[i]; // Use the previous delay if none exists.\n\n          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;\n\n          _each(controllers, function (ctrl) {\n            _each(ctrl.queue, function (props) {\n              props.delay = delay + (props.delay || 0);\n            });\n\n            ctrl.start();\n          });\n        }\n      });\n    } else {\n      var p = Promise.resolve();\n\n      _each(refs, function (ref) {\n        var _ref2 = ref.current || {},\n            controllers = _ref2.controllers,\n            start = _ref2.start;\n\n        if (controllers && controllers.length) {\n          // Take the queue of each controller\n          var updates = controllers.map(function (ctrl) {\n            var q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          }); // Apply the queue when the previous ref stops animating\n\n          p = p.then(function () {\n            _each(controllers, function (ctrl, i) {\n              var _ctrl$queue;\n\n              return (_ctrl$queue = ctrl.queue).push.apply(_ctrl$queue, _toConsumableArray(updates[i]));\n            });\n\n            return start();\n          });\n        }\n      });\n    }\n  });\n} // The `mass` prop defaults to 1\n\n\nvar config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\n\nvar linear = function linear(t) {\n  return t;\n};\n\nvar defaults = _extends(_extends({}, config.default), {}, {\n  mass: 1,\n  damping: 1,\n  easing: linear,\n  clamp: false\n});\n\nvar AnimationConfig =\n/**\n * With higher tension, the spring will resist bouncing and try harder to stop at its end value.\n *\n * When tension is zero, no animation occurs.\n */\n\n/**\n * The damping ratio coefficient, or just the damping ratio when `speed` is defined.\n *\n * When `speed` is defined, this value should be between 0 and 1.\n *\n * Higher friction means the spring will slow down faster.\n */\n\n/**\n * The natural frequency (in seconds), which dictates the number of bounces\n * per second when no damping exists.\n *\n * When defined, `tension` is derived from this, and `friction` is derived\n * from `tension` and `damping`.\n */\n\n/**\n * The damping ratio, which dictates how the spring slows down.\n *\n * Set to `0` to never slow down. Set to `1` to slow down without bouncing.\n * Between `0` and `1` is for you to explore.\n *\n * Only works when `frequency` is defined.\n *\n * Defaults to 1\n */\n\n/**\n * Higher mass means more friction is required to slow down.\n *\n * Defaults to 1, which works fine most of the time.\n */\n\n/**\n * The initial velocity of one or more values.\n */\n\n/**\n * The smallest velocity before the animation is considered \"not moving\".\n *\n * When undefined, `precision` is used instead.\n */\n\n/**\n * The smallest distance from a value before that distance is essentially zero.\n *\n * This helps in deciding when a spring is \"at rest\". The spring must be within\n * this distance from its final value, and its velocity must be lower than this\n * value too (unless `restVelocity` is defined).\n */\n\n/**\n * For `duration` animations only. Note: The `duration` is not affected\n * by this property.\n *\n * Defaults to `0`, which means \"start from the beginning\".\n *\n * Setting to `1+` makes an immediate animation.\n *\n * Setting to `0.5` means \"start from the middle of the easing function\".\n *\n * Any number `>= 0` and `<= 1` makes sense here.\n */\n\n/**\n * Animation length in number of milliseconds.\n */\n\n/**\n * The animation curve. Only used when `duration` is defined.\n *\n * Defaults to quadratic ease-in-out.\n */\n\n/**\n * Avoid overshooting by ending abruptly at the goal value.\n */\n\n/**\n * When above zero, the spring will bounce instead of overshooting when\n * exceeding its goal value. Its velocity is multiplied by `-1 + bounce`\n * whenever its current value equals or exceeds its goal. For example,\n * setting `bounce` to `0.5` chops the velocity in half on each bounce,\n * in addition to any friction.\n */\n\n/**\n * \"Decay animations\" decelerate without an explicit goal value.\n * Useful for scrolling animations.\n *\n * Use `true` for the default exponential decay factor (`0.998`).\n *\n * When a `number` between `0` and `1` is given, a lower number makes the\n * animation slow down faster. And setting to `1` would make an unending\n * animation.\n */\n\n/**\n * While animating, round to the nearest multiple of this number.\n * The `from` and `to` values are never rounded, as well as any value\n * passed to the `set` method of an animated value.\n */\nfunction AnimationConfig() {\n  _classCallCheck(this, AnimationConfig);\n\n  this.tension = void 0;\n  this.friction = void 0;\n  this.frequency = void 0;\n  this.damping = void 0;\n  this.mass = void 0;\n  this.velocity = 0;\n  this.restVelocity = void 0;\n  this.precision = void 0;\n  this.progress = void 0;\n  this.duration = void 0;\n  this.easing = void 0;\n  this.clamp = void 0;\n  this.bounce = void 0;\n  this.decay = void 0;\n  this.round = void 0;\n  Object.assign(this, defaults);\n};\n\nfunction mergeConfig(config, newConfig, defaultConfig) {\n  if (defaultConfig) {\n    defaultConfig = _extends({}, defaultConfig);\n    sanitizeConfig(defaultConfig, newConfig);\n    newConfig = _extends(_extends({}, defaultConfig), newConfig);\n  }\n\n  sanitizeConfig(config, newConfig);\n  Object.assign(config, newConfig);\n\n  for (var key in defaults) {\n    if (config[key] == null) {\n      config[key] = defaults[key];\n    }\n  }\n\n  var mass = config.mass,\n      frequency = config.frequency,\n      damping = config.damping;\n\n  if (!is.und(frequency)) {\n    if (frequency < 0.01) frequency = 0.01;\n    if (damping < 0) damping = 0;\n    config.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;\n    config.friction = 4 * Math.PI * damping * mass / frequency;\n  }\n\n  return config;\n} // Prevent a config from accidentally overriding new props.\n// This depends on which \"config\" props take precedence when defined.\n\n\nfunction sanitizeConfig(config, props) {\n  if (!is.und(props.decay)) {\n    config.duration = undefined;\n  } else {\n    var isTensionConfig = !is.und(props.tension) || !is.und(props.friction);\n\n    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {\n      config.duration = undefined;\n      config.decay = undefined;\n    }\n\n    if (isTensionConfig) {\n      config.frequency = undefined;\n    }\n  }\n}\n\nvar emptyArray = [];\n/** @internal */\n\n/** An animation being executed by the frameloop */\n\nvar Animation = function Animation() {\n  _classCallCheck(this, Animation);\n\n  this.changed = false;\n  this.values = emptyArray;\n  this.toValues = null;\n  this.fromValues = emptyArray;\n  this.to = void 0;\n  this.from = void 0;\n  this.config = new AnimationConfig();\n  this.immediate = false;\n  this.onStart = void 0;\n  this.onChange = void 0;\n  this.onRest = [];\n}; // @see https://github.com/alexreardon/use-memo-one/pull/10\n\n\nvar useMemo = function useMemo(create, deps) {\n  return useMemoOne(create, deps || [{}]);\n};\n\nfunction callProp(value) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return is.fun(value) ? value.apply(void 0, args) : value;\n}\n/** Try to coerce the given value into a boolean using the given key */\n\n\nvar matchProp = function matchProp(value, key) {\n  return value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));\n};\n\nvar getProps = function getProps(props, i, arg) {\n  return props && (is.fun(props) ? props(i, arg) : is.arr(props) ? props[i] : _extends({}, props));\n};\n/** Returns `true` if the given prop is having its default value set. */\n\n\nvar hasDefaultProp = function hasDefaultProp(props, key) {\n  return !is.und(getDefaultProp(props, key));\n};\n/** Get the default value being set for the given `key` */\n\n\nvar getDefaultProp = function getDefaultProp(props, key) {\n  return props.default === true ? props[key] : props.default ? props.default[key] : undefined;\n};\n/**\n * Extract the default props from an update.\n *\n * When the `default` prop is falsy, this function still behaves as if\n * `default: true` was used. The `default` prop is always respected when\n * truthy.\n */\n\n\nvar getDefaultProps = function getDefaultProps(props) {\n  var omitKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var defaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var keys = DEFAULT_PROPS;\n\n  if (props.default && props.default !== true) {\n    props = props.default;\n    keys = Object.keys(props);\n  }\n\n  var _iterator = _createForOfIteratorHelper(keys),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      var value = props[key];\n\n      if (!is.und(value) && !omitKeys.includes(key)) {\n        defaults[key] = value;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return defaults;\n};\n/** Merge the default props of an update into a props cache. */\n\n\nvar mergeDefaultProps = function mergeDefaultProps(defaults, props, omitKeys) {\n  return getDefaultProps(props, omitKeys, defaults);\n};\n/** These props can have default values */\n\n\nvar DEFAULT_PROPS = ['pause', 'cancel', 'config', 'immediate', 'onDelayEnd', 'onProps', 'onStart', 'onChange', 'onRest'];\nvar RESERVED_PROPS = {\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  loop: 1,\n  reset: 1,\n  pause: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  default: 1,\n  delay: 1,\n  onDelayEnd: 1,\n  onProps: 1,\n  onStart: 1,\n  onChange: 1,\n  onRest: 1,\n  // Transition props\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  update: 1,\n  leave: 1,\n  children: 1,\n  // Internal props\n  keys: 1,\n  callId: 1,\n  parentId: 1\n};\n/**\n * Extract any properties whose keys are *not* reserved for customizing your\n * animations. All hooks use this function, which means `useTransition` props\n * are reserved for `useSpring` calls, etc.\n */\n\nfunction getForwardProps(props) {\n  var forward = {};\n  var count = 0;\n\n  _each(props, function (value, prop) {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value;\n      count++;\n    }\n  });\n\n  if (count) {\n    return forward;\n  }\n}\n/**\n * Clone the given `props` and move all non-reserved props\n * into the `to` prop.\n */\n\n\nfunction inferTo(props) {\n  var to = getForwardProps(props);\n\n  if (to) {\n    var out = {\n      to\n    };\n\n    _each(props, function (val, key) {\n      return key in to || (out[key] = val);\n    });\n\n    return out;\n  }\n\n  return _extends({}, props);\n} // Compute the goal value, converting \"red\" to \"rgba(255, 0, 0, 1)\" in the process\n\n\nfunction computeGoal(value) {\n  var config = getFluidConfig(value);\n  return config ? computeGoal(config.get()) : is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n}\n/**\n * This function sets a timeout if both the `delay` prop exists and\n * the `cancel` prop is not `true`.\n *\n * The `actions.start` function must handle the `cancel` prop itself,\n * but the `pause` prop is taken care of.\n */\n\n\nfunction scheduleProps(callId, _ref3) {\n  var key = _ref3.key,\n      props = _ref3.props,\n      state = _ref3.state,\n      actions = _ref3.actions;\n  return new Promise(function (resolve, reject) {\n    var delay;\n    var timeout;\n    var pause = false;\n    var cancel = matchProp(props.cancel, key);\n\n    if (cancel) {\n      onStart();\n    } else {\n      delay = callProp(props.delay || 0, key);\n      pause = matchProp(props.pause, key);\n\n      if (pause) {\n        state.resumeQueue.add(onResume);\n        actions.pause();\n      } else {\n        actions.resume();\n        onResume();\n      }\n    }\n\n    function onPause() {\n      state.resumeQueue.add(onResume);\n      timeout.cancel(); // Cache the remaining delay.\n\n      delay = timeout.time - Globals.now();\n    }\n\n    function onResume() {\n      if (delay > 0) {\n        state.pauseQueue.add(onPause);\n        timeout = Globals.frameLoop.setTimeout(onStart, delay);\n      } else {\n        onStart();\n      }\n    }\n\n    function onStart() {\n      state.pauseQueue.delete(onPause); // Maybe cancelled during its delay.\n\n      if (callId <= (state.cancelId || 0)) {\n        cancel = true;\n      }\n\n      try {\n        actions.start(_extends(_extends({}, props), {}, {\n          callId,\n          delay,\n          cancel,\n          pause\n        }), resolve);\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n}\n/** @internal */\n\n/** The object given to the `onRest` prop and `start` promise. */\n\n/** The promised result of an animation. */\n\n/** @internal */\n\n\nvar getCombinedResult = function getCombinedResult(target, results) {\n  return results.length == 1 ? results[0] : results.some(function (result) {\n    return result.cancelled;\n  }) ? getCancelledResult(target) : results.every(function (result) {\n    return result.noop;\n  }) ? getNoopResult(target) : getFinishedResult(target, results.every(function (result) {\n    return result.finished;\n  }));\n};\n/** No-op results are for updates that never start an animation. */\n\n\nvar getNoopResult = function getNoopResult(target) {\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : target.get();\n  return {\n    value,\n    noop: true,\n    finished: true,\n    target\n  };\n};\n\nvar getFinishedResult = function getFinishedResult(target, finished) {\n  var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : target.get();\n  return {\n    value,\n    finished,\n    target\n  };\n};\n\nvar getCancelledResult = function getCancelledResult(target) {\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : target.get();\n  return {\n    value,\n    cancelled: true,\n    target\n  };\n};\n/**\n * Start an async chain or an async script.\n *\n * Always call `runAsync` in the action callback of a `scheduleProps` call.\n *\n * The `T` parameter can be a set of animated values (as an object type)\n * or a primitive type for a single animated value.\n */\n\n\nfunction runAsync(_x, _x2, _x3, _x4) {\n  return _runAsync.apply(this, arguments);\n}\n\nfunction _runAsync() {\n  _runAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(to, props, state, target) {\n    var callId, parentId, onRest, prevTo, prevPromise;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (!props.pause) {\n              _context6.next = 3;\n              break;\n            }\n\n            _context6.next = 3;\n            return new Promise(function (resume) {\n              state.resumeQueue.add(resume);\n            });\n\n          case 3:\n            callId = props.callId, parentId = props.parentId, onRest = props.onRest;\n            prevTo = state.asyncTo, prevPromise = state.promise;\n\n            if (!(!parentId && to === prevTo && !props.reset)) {\n              _context6.next = 7;\n              break;\n            }\n\n            return _context6.abrupt(\"return\", prevPromise);\n\n          case 7:\n            return _context6.abrupt(\"return\", state.promise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n              var defaultProps, preventBail, bail, bailPromise, withBailHandler, bailIfEnded, animate, result, animating;\n              return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                while (1) {\n                  switch (_context5.prev = _context5.next) {\n                    case 0:\n                      state.asyncId = callId;\n                      state.asyncTo = to; // The default props of any `animate` calls.\n\n                      defaultProps = getDefaultProps(props, [// The `onRest` prop is only called when the `runAsync` promise is resolved.\n                      'onRest']);\n                      // This promise is rejected when the animation is interrupted.\n                      bailPromise = new Promise(function (resolve, reject) {\n                        return preventBail = resolve, bail = reject;\n                      }); // Stop animating when an error is caught.\n\n                      withBailHandler = function withBailHandler(fn) {\n                        return function () {\n                          var onError = function onError(err) {\n                            if (err instanceof BailSignal) {\n                              bail(err); // Stop animating.\n                            }\n\n                            throw err;\n                          };\n\n                          try {\n                            return fn.apply(void 0, arguments).catch(onError);\n                          } catch (err) {\n                            onError(err);\n                          }\n                        };\n                      };\n\n                      bailIfEnded = function bailIfEnded(bailSignal) {\n                        var bailResult = // The `cancel` prop or `stop` method was used.\n                        callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.\n                        callId !== state.asyncId && getFinishedResult(target, false);\n\n                        if (bailResult) {\n                          bailSignal.result = bailResult;\n                          throw bailSignal;\n                        }\n                      }; // Note: This function cannot use the `async` keyword, because we want the\n                      // `throw` statements to interrupt the caller.\n\n\n                      animate = withBailHandler(function (arg1, arg2) {\n                        var bailSignal = new BailSignal();\n                        bailIfEnded(bailSignal);\n                        var props = is.obj(arg1) ? _extends({}, arg1) : _extends(_extends({}, arg2), {}, {\n                          to: arg1\n                        });\n                        props.parentId = callId;\n\n                        _each(defaultProps, function (value, key) {\n                          if (is.und(props[key])) {\n                            props[key] = value;\n                          }\n                        });\n\n                        return target.start(props).then( /*#__PURE__*/function () {\n                          var _ref15 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(result) {\n                            return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                              while (1) {\n                                switch (_context3.prev = _context3.next) {\n                                  case 0:\n                                    bailIfEnded(bailSignal);\n\n                                    if (!target.is('PAUSED')) {\n                                      _context3.next = 4;\n                                      break;\n                                    }\n\n                                    _context3.next = 4;\n                                    return new Promise(function (resume) {\n                                      state.resumeQueue.add(resume);\n                                    });\n\n                                  case 4:\n                                    return _context3.abrupt(\"return\", result);\n\n                                  case 5:\n                                  case \"end\":\n                                    return _context3.stop();\n                                }\n                              }\n                            }, _callee3);\n                          }));\n\n                          return function (_x7) {\n                            return _ref15.apply(this, arguments);\n                          };\n                        }());\n                      });\n                      _context5.prev = 7;\n\n                      // Async sequence\n                      if (is.arr(to)) {\n                        animating = function () {\n                          var _ref16 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(queue) {\n                            var _iterator2, _step2, _props2;\n\n                            return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                              while (1) {\n                                switch (_context4.prev = _context4.next) {\n                                  case 0:\n                                    _iterator2 = _createForOfIteratorHelper(queue);\n                                    _context4.prev = 1;\n\n                                    _iterator2.s();\n\n                                  case 3:\n                                    if ((_step2 = _iterator2.n()).done) {\n                                      _context4.next = 9;\n                                      break;\n                                    }\n\n                                    _props2 = _step2.value;\n                                    _context4.next = 7;\n                                    return animate(_props2);\n\n                                  case 7:\n                                    _context4.next = 3;\n                                    break;\n\n                                  case 9:\n                                    _context4.next = 14;\n                                    break;\n\n                                  case 11:\n                                    _context4.prev = 11;\n                                    _context4.t0 = _context4[\"catch\"](1);\n\n                                    _iterator2.e(_context4.t0);\n\n                                  case 14:\n                                    _context4.prev = 14;\n\n                                    _iterator2.f();\n\n                                    return _context4.finish(14);\n\n                                  case 17:\n                                  case \"end\":\n                                    return _context4.stop();\n                                }\n                              }\n                            }, _callee4, null, [[1, 11, 14, 17]]);\n                          }));\n\n                          return function (_x8) {\n                            return _ref16.apply(this, arguments);\n                          };\n                        }()(to);\n                      } // Async script\n                      else if (is.fun(to)) {\n                          animating = Promise.resolve(to(animate, target.stop.bind(target)));\n                        }\n\n                      _context5.next = 11;\n                      return Promise.all([animating.then(preventBail), bailPromise]);\n\n                    case 11:\n                      result = getFinishedResult(target, true); // Bail handling\n\n                      _context5.next = 21;\n                      break;\n\n                    case 14:\n                      _context5.prev = 14;\n                      _context5.t0 = _context5[\"catch\"](7);\n\n                      if (!(_context5.t0 instanceof BailSignal)) {\n                        _context5.next = 20;\n                        break;\n                      }\n\n                      result = _context5.t0.result;\n                      _context5.next = 21;\n                      break;\n\n                    case 20:\n                      throw _context5.t0;\n\n                    case 21:\n                      _context5.prev = 21;\n\n                      if (callId == state.asyncId) {\n                        state.asyncId = parentId;\n                        state.asyncTo = parentId ? prevTo : undefined;\n                        state.promise = parentId ? prevPromise : undefined;\n                      }\n\n                      return _context5.finish(21);\n\n                    case 24:\n                      if (is.fun(onRest)) {\n                        batchedUpdates(function () {\n                          onRest(result);\n                        });\n                      }\n\n                      return _context5.abrupt(\"return\", result);\n\n                    case 26:\n                    case \"end\":\n                      return _context5.stop();\n                  }\n                }\n              }, _callee5, null, [[7, 14, 21, 24]]);\n            }))());\n\n          case 8:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _runAsync.apply(this, arguments);\n}\n\nfunction cancelAsync(state, callId) {\n  state.cancelId = callId;\n  state.asyncId = state.asyncTo = state.promise = undefined;\n}\n/** This error is thrown to signal an interrupted async animation. */\n\n\nvar BailSignal = /*#__PURE__*/function (_Error) {\n  _inherits(BailSignal, _Error);\n\n  var _super = _createSuper(BailSignal);\n\n  function BailSignal() {\n    var _this;\n\n    _classCallCheck(this, BailSignal);\n\n    _this = _super.call(this, 'An async animation has been interrupted. You see this error because you ' + 'forgot to use `await` or `.catch(...)` on its returned promise.');\n    _this.result = void 0;\n    return _this;\n  }\n\n  return BailSignal;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar isFrameValue = function isFrameValue(value) {\n  return value instanceof FrameValue;\n};\n\nvar nextId = 1;\n/**\n * A kind of `FluidValue` that manages an `AnimatedValue` node.\n *\n * Its underlying value can be accessed and even observed.\n */\n\nvar FrameValue = /*#__PURE__*/function (_FluidValue) {\n  _inherits(FrameValue, _FluidValue);\n\n  var _super2 = _createSuper(FrameValue);\n\n  function FrameValue() {\n    var _this2;\n\n    _classCallCheck(this, FrameValue);\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    _this2 = _super2.call.apply(_super2, [this].concat(args));\n    _this2.id = nextId++;\n    _this2.key = void 0;\n    _this2._priority = 0;\n    _this2._children = new Set();\n    return _this2;\n  }\n\n  _createClass(FrameValue, [{\n    key: \"get\",\n\n    /** Get the current value */\n    value: function get() {\n      var node = getAnimated(this);\n      return node && node.getValue();\n    }\n    /** Create a spring that maps our value to another value */\n\n  }, {\n    key: \"to\",\n    value: function to() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return to$1(this, args);\n    }\n    /** @deprecated Use the `to` method instead. */\n\n  }, {\n    key: \"interpolate\",\n    value: function interpolate() {\n      deprecateInterpolate();\n\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return to$1(this, args);\n    }\n    /** @internal */\n\n    /** @internal */\n\n  }, {\n    key: \"addChild\",\n    value: function addChild(child) {\n      if (!this._children.size) this._attach();\n\n      this._children.add(child);\n    }\n    /** @internal */\n\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(child) {\n      this._children.delete(child);\n\n      if (!this._children.size) this._detach();\n    }\n    /** @internal */\n\n  }, {\n    key: \"onParentChange\",\n    value: function onParentChange(_ref4) {\n      var type = _ref4.type;\n\n      if (this.idle) {\n        // Start animating when a parent does.\n        if (type == 'start') {\n          this._reset();\n\n          this._start();\n        }\n      } // Reset our animation state when a parent does, but only when\n      // our animation is active.\n      else if (type == 'reset') {\n          this._reset();\n        }\n    }\n    /** Called when the first child is added. */\n\n  }, {\n    key: \"_attach\",\n    value: function _attach() {}\n    /** Called when the last child is removed. */\n\n  }, {\n    key: \"_detach\",\n    value: function _detach() {}\n    /**\n     * Reset our animation state (eg: start values, velocity, etc)\n     * and tell our children to do the same.\n     *\n     * This is called when our goal value is changed during (or before)\n     * an animation.\n     */\n\n  }, {\n    key: \"_reset\",\n    value: function _reset() {\n      this._emit({\n        type: 'reset',\n        parent: this\n      });\n    }\n    /**\n     * Start animating if possible.\n     *\n     * Note: Be sure to call `_reset` first, or the animation will break.\n     * This method would like to call `_reset` for you, but that would\n     * interfere with paused animations.\n     */\n\n  }, {\n    key: \"_start\",\n    value: function _start() {\n      this._emit({\n        type: 'start',\n        parent: this\n      });\n    }\n    /** Tell our children about our new value */\n\n  }, {\n    key: \"_onChange\",\n    value: function _onChange(value) {\n      var idle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      this._emit({\n        type: 'change',\n        parent: this,\n        value,\n        idle\n      });\n    }\n    /** Tell our children about our new priority */\n\n  }, {\n    key: \"_onPriorityChange\",\n    value: function _onPriorityChange(priority) {\n      if (!this.idle) {\n        // Make the frameloop aware of our new priority.\n        frameLoop.start(this);\n      }\n\n      this._emit({\n        type: 'priority',\n        parent: this,\n        priority\n      });\n    }\n  }, {\n    key: \"_emit\",\n    value: function _emit(event) {\n      // Clone \"_children\" so it can be safely mutated inside the loop.\n      _each(Array.from(this._children), function (child) {\n        child.onParentChange(event);\n      });\n    }\n  }, {\n    key: \"priority\",\n    get: function get() {\n      return this._priority;\n    },\n    set: function set(priority) {\n      if (this._priority != priority) {\n        this._priority = priority;\n\n        this._onPriorityChange(priority);\n      }\n    }\n  }]);\n\n  return FrameValue;\n}(FluidValue); // TODO: use \"const enum\" when Babel supports it\n\n/** The spring has not animated yet */\n\n\nvar CREATED = 'CREATED';\n/** The spring has animated before */\n\nvar IDLE = 'IDLE';\n/** The spring is animating */\n\nvar ACTIVE = 'ACTIVE';\n/** The spring is frozen in time */\n\nvar PAUSED = 'PAUSED';\n/** The spring cannot be animated */\n\nvar DISPOSED = 'DISPOSED';\n/**\n * Only numbers, strings, and arrays of numbers/strings are supported.\n * Non-animatable strings are also supported.\n */\n\nvar SpringValue = /*#__PURE__*/function (_FrameValue) {\n  _inherits(SpringValue, _FrameValue);\n\n  var _super3 = _createSuper(SpringValue);\n\n  /** The property name used when `to` or `from` is an object. Useful when debugging too. */\n\n  /** The animation state */\n\n  /** The queue of pending props */\n\n  /** The lifecycle phase of this spring */\n\n  /** The state for `runAsync` calls */\n\n  /** Some props have customizable default values */\n\n  /** The counter for tracking `scheduleProps` calls */\n\n  /** The last `scheduleProps` call that changed the `to` prop */\n  function SpringValue(arg1, arg2) {\n    var _this3;\n\n    _classCallCheck(this, SpringValue);\n\n    _this3 = _super3.call(this);\n    _this3.key = void 0;\n    _this3.animation = new Animation();\n    _this3.queue = void 0;\n    _this3._phase = CREATED;\n    _this3._state = {\n      pauseQueue: new Set(),\n      resumeQueue: new Set()\n    };\n    _this3._defaultProps = {};\n    _this3._lastCallId = 0;\n    _this3._lastToId = 0;\n\n    if (!is.und(arg1) || !is.und(arg2)) {\n      var props = is.obj(arg1) ? _extends({}, arg1) : _extends(_extends({}, arg2), {}, {\n        from: arg1\n      });\n      props.default = true;\n\n      _this3.start(props);\n    }\n\n    return _this3;\n  }\n\n  _createClass(SpringValue, [{\n    key: \"advance\",\n\n    /** Advance the current animation by a number of milliseconds */\n    value: function advance(dt) {\n      var _this4 = this;\n\n      var idle = true;\n      var changed = false;\n      var anim = this.animation;\n      var config = anim.config,\n          toValues = anim.toValues;\n      var payload = getPayload(anim.to);\n\n      if (!payload) {\n        var toConfig = getFluidConfig(anim.to);\n\n        if (toConfig) {\n          toValues = toArray(toConfig.get());\n        }\n      }\n\n      anim.values.forEach(function (node, i) {\n        if (node.done) return; // The \"anim.toValues\" array must exist when no parent exists.\n\n        var to = payload ? payload[i].lastPosition : toValues[i];\n        var finished = anim.immediate;\n        var position = to;\n\n        if (!finished) {\n          position = node.lastPosition; // Loose springs never move.\n\n          if (config.tension <= 0) {\n            node.done = true;\n            return;\n          }\n\n          var elapsed = node.elapsedTime += dt;\n          var from = anim.fromValues[i];\n          var v0 = node.v0 != null ? node.v0 : node.v0 = is.arr(config.velocity) ? config.velocity[i] : config.velocity;\n          var velocity; // Duration easing\n\n          if (!is.und(config.duration)) {\n            var p = config.progress || 0;\n            if (config.duration <= 0) p = 1;else p += (1 - p) * Math.min(1, elapsed / config.duration);\n            position = from + config.easing(p) * (to - from);\n            velocity = (position - node.lastPosition) / dt;\n            finished = p == 1;\n          } // Decay easing\n          else if (config.decay) {\n              var decay = config.decay === true ? 0.998 : config.decay;\n              var e = Math.exp(-(1 - decay) * elapsed);\n              position = from + v0 / (1 - decay) * (1 - e);\n              finished = Math.abs(node.lastPosition - position) < 0.1; // derivative of position\n\n              velocity = v0 * e;\n            } // Spring easing\n            else {\n                velocity = node.lastVelocity == null ? v0 : node.lastVelocity;\n                /** The smallest distance from a value before being treated like said value. */\n\n                var precision = config.precision || (from == to ? 0.005 : Math.min(1, Math.abs(to - from) * 0.001));\n                /** The velocity at which movement is essentially none */\n\n                var restVelocity = config.restVelocity || precision / 10; // Bouncing is opt-in (not to be confused with overshooting)\n\n                var bounceFactor = config.clamp ? 0 : config.bounce;\n                var canBounce = !is.und(bounceFactor);\n                /** When `true`, the value is increasing over time */\n\n                var isGrowing = from == to ? node.v0 > 0 : from < to;\n                /** When `true`, the velocity is considered moving */\n\n                var isMoving;\n                /** When `true`, the velocity is being deflected or clamped */\n\n                var isBouncing = false;\n                var step = 1; // 1ms\n\n                var numSteps = Math.ceil(dt / step);\n\n                for (var n = 0; n < numSteps; ++n) {\n                  isMoving = Math.abs(velocity) > restVelocity;\n\n                  if (!isMoving) {\n                    finished = Math.abs(to - position) <= precision;\n\n                    if (finished) {\n                      break;\n                    }\n                  }\n\n                  if (canBounce) {\n                    isBouncing = position == to || position > to == isGrowing; // Invert the velocity with a magnitude, or clamp it.\n\n                    if (isBouncing) {\n                      velocity = -velocity * bounceFactor;\n                      position = to;\n                    }\n                  }\n\n                  var springForce = -config.tension * 0.000001 * (position - to);\n                  var dampingForce = -config.friction * 0.001 * velocity;\n                  var acceleration = (springForce + dampingForce) / config.mass; // pt/ms^2\n\n                  velocity = velocity + acceleration * step; // pt/ms\n\n                  position = position + velocity * step;\n                }\n              }\n\n          node.lastVelocity = velocity;\n\n          if (Number.isNaN(position)) {\n            console.warn(\"Got NaN while animating:\", _this4);\n            finished = true;\n          }\n        } // Parent springs must finish before their children can.\n\n\n        if (payload && !payload[i].done) {\n          finished = false;\n        }\n\n        if (finished) {\n          node.done = true;\n        } else {\n          idle = false;\n        }\n\n        if (node.setValue(position, config.round)) {\n          changed = true;\n        }\n      });\n\n      if (idle) {\n        this.finish();\n      } else if (changed) {\n        this._onChange(this.get());\n      }\n\n      return idle;\n    }\n    /** Check the current phase */\n\n  }, {\n    key: \"is\",\n    value: function is(phase) {\n      return this._phase == phase;\n    }\n    /** Set the current value, while stopping the current animation */\n\n  }, {\n    key: \"set\",\n    value: function set(value) {\n      var _this5 = this;\n\n      batchedUpdates(function () {\n        _this5._focus(value);\n\n        if (_this5._set(value)) {\n          // Ensure change observers are notified. When active,\n          // the \"_stop\" method handles this.\n          if (!_this5.is(ACTIVE)) {\n            return _this5._onChange(_this5.get(), true);\n          }\n        }\n\n        _this5._stop();\n      });\n      return this;\n    }\n    /**\n     * Freeze the active animation in time.\n     * This does nothing when not animating.\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      checkDisposed(this, 'pause');\n\n      if (!this.is(PAUSED)) {\n        this._phase = PAUSED;\n        flush(this._state.pauseQueue, function (onPause) {\n          return onPause();\n        });\n      }\n    }\n    /** Resume the animation if paused. */\n\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      checkDisposed(this, 'resume');\n\n      if (this.is(PAUSED)) {\n        this._start();\n\n        flush(this._state.resumeQueue, function (onResume) {\n          return onResume();\n        });\n      }\n    }\n    /**\n     * Skip to the end of the current animation.\n     *\n     * All `onRest` callbacks are passed `{finished: true}`\n     */\n\n  }, {\n    key: \"finish\",\n    value: function finish(to) {\n      var _this6 = this;\n\n      this.resume();\n\n      if (this.is(ACTIVE)) {\n        var anim = this.animation; // Decay animations have an implicit goal.\n\n        if (!anim.config.decay && is.und(to)) {\n          to = anim.to;\n        } // Set the value if we can.\n\n\n        if (!is.und(to)) {\n          this._set(to);\n        }\n\n        batchedUpdates(function () {\n          // Ensure the \"onStart\" and \"onRest\" props are called.\n          if (!anim.changed) {\n            anim.changed = true;\n\n            if (anim.onStart) {\n              anim.onStart(_this6);\n            }\n          } // Exit the frameloop.\n\n\n          _this6._stop();\n        });\n      }\n\n      return this;\n    }\n    /** Push props into the pending queue. */\n\n  }, {\n    key: \"update\",\n    value: function update(props) {\n      checkDisposed(this, 'update');\n      var queue = this.queue || (this.queue = []);\n      queue.push(props);\n      return this;\n    }\n    /**\n     * Update this value's animation using the queue of pending props,\n     * and unpause the current animation (if one is frozen).\n     *\n     * When arguments are passed, a new animation is created, and the\n     * queued animations are left alone.\n     */\n\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(to, arg2) {\n        var _this7 = this;\n\n        var queue, results;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                checkDisposed(this, 'start');\n\n                if (!is.und(to)) {\n                  queue = [is.obj(to) ? to : _extends(_extends({}, arg2), {}, {\n                    to\n                  })];\n                } else {\n                  queue = this.queue || [];\n                  this.queue = [];\n                }\n\n                _context.next = 4;\n                return Promise.all(queue.map(function (props) {\n                  return _this7._update(props);\n                }));\n\n              case 4:\n                results = _context.sent;\n                return _context.abrupt(\"return\", getCombinedResult(this, results));\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function start(_x5, _x6) {\n        return _start2.apply(this, arguments);\n      }\n\n      return start;\n    }()\n    /**\n     * Stop the current animation, and cancel any delayed updates.\n     *\n     * Pass `true` to call `onRest` with `cancelled: true`.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(cancel) {\n      var _this8 = this;\n\n      if (!this.is(DISPOSED)) {\n        cancelAsync(this._state, this._lastCallId); // Ensure the `to` value equals the current value.\n\n        this._focus(this.get()); // Exit the frameloop and notify `onRest` listeners.\n\n\n        batchedUpdates(function () {\n          return _this8._stop(cancel);\n        });\n      }\n\n      return this;\n    }\n    /** Restart the animation. */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._update({\n        reset: true\n      });\n    }\n    /** Prevent future animations, and stop the current animation */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (!this.is(DISPOSED)) {\n        if (this.animation) {\n          // Prevent \"onRest\" calls when disposed.\n          this.animation.onRest = [];\n        }\n\n        this.stop();\n        this._phase = DISPOSED;\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"onParentChange\",\n    value: function onParentChange(event) {\n      _get(_getPrototypeOf(SpringValue.prototype), \"onParentChange\", this).call(this, event);\n\n      if (event.type == 'change') {\n        if (!this.is(ACTIVE)) {\n          this._reset();\n\n          if (!this.is(PAUSED)) {\n            this._start();\n          }\n        }\n      } else if (event.type == 'priority') {\n        this.priority = event.priority + 1;\n      }\n    }\n    /**\n     * Parse the `to` and `from` range from the given `props` object.\n     *\n     * This also ensures the initial value is available to animated components\n     * during the render phase.\n     */\n\n  }, {\n    key: \"_prepareNode\",\n    value: function _prepareNode(_ref5) {\n      var to = _ref5.to,\n          from = _ref5.from,\n          reverse = _ref5.reverse;\n      var key = this.key || '';\n      to = !is.obj(to) || getFluidConfig(to) ? to : to[key];\n      from = !is.obj(from) || getFluidConfig(from) ? from : from[key]; // Create the range now to avoid \"reverse\" logic.\n\n      var range = {\n        to,\n        from\n      }; // Before ever animating, this method ensures an `Animated` node\n      // exists and keeps its value in sync with the \"from\" prop.\n\n      if (this.is(CREATED)) {\n        if (reverse) {\n          var _ref6 = [from, to];\n          to = _ref6[0];\n          from = _ref6[1];\n        }\n\n        from = getFluidValue(from);\n\n        var node = this._updateNode(is.und(from) ? getFluidValue(to) : from);\n\n        if (node && !is.und(from)) {\n          node.setValue(from);\n        }\n      }\n\n      return range;\n    }\n    /**\n     * Create an `Animated` node if none exists or the given value has an\n     * incompatible type. Do nothing if `value` is undefined.\n     *\n     * The newest `Animated` node is returned.\n     */\n\n  }, {\n    key: \"_updateNode\",\n    value: function _updateNode(value) {\n      var node = getAnimated(this);\n\n      if (!is.und(value)) {\n        var nodeType = this._getNodeType(value);\n\n        if (!node || node.constructor !== nodeType) {\n          setAnimated(this, node = nodeType.create(value));\n        }\n      }\n\n      return node;\n    }\n    /** Return the `Animated` node constructor for a given value */\n\n  }, {\n    key: \"_getNodeType\",\n    value: function _getNodeType(value) {\n      var parentNode = getAnimated(value);\n      return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;\n    }\n    /** Schedule an animation to run after an optional delay */\n\n  }, {\n    key: \"_update\",\n    value: function _update(props, isLoop) {\n      var _this9 = this;\n\n      var defaultProps = this._defaultProps;\n\n      var mergeDefaultProp = function mergeDefaultProp(key) {\n        var value = getDefaultProp(props, key);\n\n        if (!is.und(value)) {\n          defaultProps[key] = value;\n        } // For `cancel` and `pause`, a truthy default always wins.\n\n\n        if (defaultProps[key]) {\n          props[key] = defaultProps[key];\n        }\n      }; // These props are coerced into booleans by the `scheduleProps` function,\n      // so they need their default values processed before then.\n\n\n      mergeDefaultProp('cancel');\n      mergeDefaultProp('pause'); // Ensure the initial value can be accessed by animated components.\n\n      var range = this._prepareNode(props);\n\n      return scheduleProps(++this._lastCallId, {\n        key: this.key,\n        props,\n        state: this._state,\n        actions: {\n          pause: this.pause.bind(this),\n          resume: this.resume.bind(this),\n          start: this._merge.bind(this, range)\n        }\n      }).then(function (result) {\n        if (props.loop && result.finished && !(isLoop && result.noop)) {\n          var nextProps = createLoopUpdate(props);\n\n          if (nextProps) {\n            return _this9._update(nextProps, true);\n          }\n        }\n\n        return result;\n      });\n    }\n    /** Merge props into the current animation */\n\n  }, {\n    key: \"_merge\",\n    value: function _merge(range, props, resolve) {\n      // The \"cancel\" prop cancels all pending delays and it forces the\n      // active animation to stop where it is.\n      if (props.cancel) {\n        this.stop(true);\n        return resolve(getCancelledResult(this));\n      }\n\n      var key = this.key,\n          anim = this.animation;\n      var defaultProps = this._defaultProps;\n      /** The \"to\" prop is defined. */\n\n      var hasToProp = !is.und(range.to);\n      /** The \"from\" prop is defined. */\n\n      var hasFromProp = !is.und(range.from); // Avoid merging other props if implicitly prevented, except\n      // when both the \"to\" and \"from\" props are undefined.\n\n      if (hasToProp || hasFromProp) {\n        if (props.callId > this._lastToId) {\n          this._lastToId = props.callId;\n        } else {\n          return resolve(getCancelledResult(this));\n        }\n      }\n      /** Get the value of a prop, or its default value */\n\n\n      var get = function get(prop) {\n        return !is.und(props[prop]) ? props[prop] : defaultProps[prop];\n      }; // Call \"onDelayEnd\" before merging props, but after cancellation checks.\n\n\n      var onDelayEnd = coerceEventProp(get('onDelayEnd'), key);\n\n      if (onDelayEnd) {\n        onDelayEnd(props, this);\n      }\n\n      if (props.default) {\n        mergeDefaultProps(defaultProps, props, ['pause', 'cancel']);\n      }\n\n      var prevTo = anim.to,\n          prevFrom = anim.from;\n      var _range$to = range.to,\n          to = _range$to === void 0 ? prevTo : _range$to,\n          _range$from = range.from,\n          from = _range$from === void 0 ? prevFrom : _range$from; // Focus the \"from\" value if changing without a \"to\" value.\n\n      if (hasFromProp && !hasToProp) {\n        to = from;\n      } // Flip the current range if \"reverse\" is true.\n\n\n      if (props.reverse) {\n        var _ref7 = [from, to];\n        to = _ref7[0];\n        from = _ref7[1];\n      }\n      /** The \"from\" value is changing. */\n\n\n      var hasFromChanged = !isEqual(from, prevFrom);\n\n      if (hasFromChanged) {\n        anim.from = from;\n      }\n      /** The \"to\" value is changing. */\n\n\n      var hasToChanged = !isEqual(to, prevTo);\n\n      if (hasToChanged) {\n        this._focus(to);\n      } // Both \"from\" and \"to\" can use a fluid config (thanks to http://npmjs.org/fluids).\n\n\n      var toConfig = getFluidConfig(to);\n      var fromConfig = getFluidConfig(from);\n\n      if (fromConfig) {\n        from = fromConfig.get();\n      }\n      /** The \"to\" prop is async. */\n\n\n      var hasAsyncTo = is.arr(props.to) || is.fun(props.to);\n      var config = anim.config;\n      var decay = config.decay,\n          velocity = config.velocity; // The \"runAsync\" function treats the \"config\" prop as a default,\n      // so we must avoid merging it when the \"to\" prop is async.\n\n      if (props.config && !hasAsyncTo) {\n        mergeConfig(config, callProp(props.config, key), // Avoid calling the same \"config\" prop twice.\n        props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0);\n      } // This instance might not have its Animated node yet. For example,\n      // the constructor can be given props without a \"to\" or \"from\" value.\n\n\n      var node = getAnimated(this);\n\n      if (!node || is.und(to)) {\n        return resolve(getFinishedResult(this, true));\n      }\n      /** When true, start at the \"from\" value. */\n\n\n      var reset = // When `reset` is undefined, the `from` prop implies `reset: true`,\n      // except for declarative updates. When `reset` is defined, there\n      // must exist a value to animate from.\n      is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key); // The current value, where the animation starts from.\n\n      var value = reset ? from : this.get(); // The animation ends at this value, unless \"to\" is fluid.\n\n      var goal = computeGoal(to); // Only specific types can be animated to/from.\n\n      var isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal); // When true, the value changes instantly on the next frame.\n\n      var immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));\n\n      if (hasToChanged) {\n        if (immediate) {\n          node = this._updateNode(goal);\n        } else {\n          var nodeType = this._getNodeType(to);\n\n          if (nodeType !== node.constructor) {\n            throw Error(\"Cannot animate between \" + node.constructor.name + \" and \" + nodeType.name + \", as the \\\"to\\\" prop suggests\");\n          }\n        }\n      } // The type of Animated node for the goal value.\n\n\n      var goalType = node.constructor; // When the goal value is fluid, we don't know if its value\n      // will change before the next animation frame, so it always\n      // starts the animation to be safe.\n\n      var started = !!toConfig;\n      var finished = false;\n\n      if (!started) {\n        // When true, the current value has probably changed.\n        var hasValueChanged = reset || this.is(CREATED) && hasFromChanged; // When the \"to\" value or current value are changed,\n        // start animating if not already finished.\n\n        if (hasToChanged || hasValueChanged) {\n          finished = isEqual(computeGoal(value), goal);\n          started = !finished;\n        } // Changing \"decay\" or \"velocity\" starts the animation.\n\n\n        if (!isEqual(config.decay, decay) || !isEqual(config.velocity, velocity)) {\n          started = true;\n        }\n      } // When an active animation changes its goal to its current value:\n\n\n      if (finished && this.is(ACTIVE)) {\n        // Avoid an abrupt stop unless the animation is being reset.\n        if (anim.changed && !reset) {\n          started = true;\n        } // Stop the animation before its first frame.\n        else if (!started) {\n            this._stop();\n          }\n      }\n\n      if (!hasAsyncTo) {\n        // Make sure our \"toValues\" are updated even if our previous\n        // \"to\" prop is a fluid value whose current value is also ours.\n        if (started || getFluidConfig(prevTo)) {\n          anim.values = node.getPayload();\n          anim.toValues = toConfig ? null : goalType == AnimatedString ? [1] : toArray(goal);\n        }\n\n        anim.immediate = immediate;\n        anim.onStart = coerceEventProp(get('onStart'), key);\n        anim.onChange = coerceEventProp(get('onChange'), key); // The \"reset\" prop tries to reuse the old \"onRest\" prop,\n        // unless you defined a new \"onRest\" prop.\n\n        var onRestQueue = anim.onRest;\n        var onRest = reset && !props.onRest ? onRestQueue[0] || noop : checkFinishedOnRest(coerceEventProp(get('onRest'), key), this); // In most cases, the animation after this one won't reuse our\n        // \"onRest\" prop. Instead, the _default_ \"onRest\" prop is used\n        // when the next animation has an undefined \"onRest\" prop.\n\n        if (started) {\n          anim.onRest = [onRest, checkFinishedOnRest(resolve, this)]; // Flush the \"onRest\" queue for the previous animation.\n\n          var onRestIndex = reset ? 0 : 1;\n\n          if (onRestIndex < onRestQueue.length) {\n            batchedUpdates(function () {\n              for (; onRestIndex < onRestQueue.length; onRestIndex++) {\n                onRestQueue[onRestIndex]();\n              }\n            });\n          }\n        } // The \"onRest\" prop is always first, and it can be updated even\n        // if a new animation is not started by this update.\n        else if (reset || props.onRest) {\n            anim.onRest[0] = onRest;\n          }\n      } // By this point, every prop has been merged.\n\n\n      var onProps = coerceEventProp(get('onProps'), key);\n\n      if (onProps) {\n        onProps(props, this);\n      } // Update our node even if the animation is idle.\n\n\n      if (reset) {\n        node.setValue(value);\n      }\n\n      if (hasAsyncTo) {\n        resolve(runAsync(props.to, props, this._state, this));\n      } // Start an animation\n      else if (started) {\n          // Must be idle for \"onStart\" to be called again.\n          if (reset) this._phase = IDLE;\n\n          this._reset();\n\n          this._start();\n        } // Postpone promise resolution until the animation is finished,\n        // so that no-op updates still resolve at the expected time.\n        else if (this.is(ACTIVE) && !hasToChanged) {\n            anim.onRest.push(checkFinishedOnRest(resolve, this));\n          } // Resolve our promise immediately.\n          else {\n              resolve(getNoopResult(this, value));\n            }\n    }\n    /** Update the `animation.to` value, which might be a `FluidValue` */\n\n  }, {\n    key: \"_focus\",\n    value: function _focus(value) {\n      var anim = this.animation;\n\n      if (value !== anim.to) {\n        var _config = getFluidConfig(anim.to);\n\n        if (_config) {\n          _config.removeChild(this);\n        }\n\n        anim.to = value;\n        var priority = 0;\n\n        if (_config = getFluidConfig(value)) {\n          _config.addChild(this);\n\n          if (isFrameValue(value)) {\n            priority = (value.priority || 0) + 1;\n          }\n        }\n\n        this.priority = priority;\n      }\n    }\n    /** Set the current value and our `node` if necessary. The `_onChange` method is *not* called. */\n\n  }, {\n    key: \"_set\",\n    value: function _set(value) {\n      var config = getFluidConfig(value);\n\n      if (config) {\n        value = config.get();\n      }\n\n      var node = getAnimated(this);\n      var oldValue = node && node.getValue();\n\n      if (node) {\n        node.setValue(value);\n      } else {\n        this._updateNode(value);\n      }\n\n      return !isEqual(value, oldValue);\n    }\n  }, {\n    key: \"_onChange\",\n    value: function _onChange(value) {\n      var idle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var anim = this.animation; // The \"onStart\" prop is called on the first change after entering the\n      // frameloop, but never for immediate animations.\n\n      if (!anim.changed && !idle) {\n        anim.changed = true;\n\n        if (anim.onStart) {\n          anim.onStart(this);\n        }\n      }\n\n      if (anim.onChange) {\n        anim.onChange(value, this);\n      }\n\n      _get(_getPrototypeOf(SpringValue.prototype), \"_onChange\", this).call(this, value, idle);\n    }\n  }, {\n    key: \"_reset\",\n    value: function _reset() {\n      var anim = this.animation; // Reset the state of each Animated node.\n\n      getAnimated(this).reset(anim.to); // Ensure the `onStart` prop will be called.\n\n      if (!this.is(ACTIVE)) {\n        anim.changed = false;\n      } // Use the current values as the from values.\n\n\n      if (!anim.immediate) {\n        anim.fromValues = anim.values.map(function (node) {\n          return node.lastPosition;\n        });\n      }\n\n      _get(_getPrototypeOf(SpringValue.prototype), \"_reset\", this).call(this);\n    }\n  }, {\n    key: \"_start\",\n    value: function _start() {\n      if (!this.is(ACTIVE)) {\n        this._phase = ACTIVE;\n\n        _get(_getPrototypeOf(SpringValue.prototype), \"_start\", this).call(this); // The \"skipAnimation\" global avoids the frameloop.\n\n\n        if (skipAnimation) {\n          this.finish();\n        } else {\n          frameLoop.start(this);\n        }\n      }\n    }\n    /**\n     * Exit the frameloop and notify `onRest` listeners.\n     *\n     * Always wrap `_stop` calls with `batchedUpdates`.\n     */\n\n  }, {\n    key: \"_stop\",\n    value: function _stop(cancel) {\n      this.resume();\n\n      if (this.is(ACTIVE)) {\n        this._phase = IDLE; // Always let change observers know when a spring becomes idle.\n\n        this._onChange(this.get(), true);\n\n        var anim = this.animation;\n\n        _each(anim.values, function (node) {\n          node.done = true;\n        });\n\n        var onRestQueue = anim.onRest;\n\n        if (onRestQueue.length) {\n          // Preserve the \"onRest\" prop when the goal is dynamic.\n          anim.onRest = [anim.toValues ? noop : onRestQueue[0]]; // Never call the \"onRest\" prop for no-op animations.\n\n          if (!anim.changed) {\n            onRestQueue[0] = noop;\n          }\n\n          _each(onRestQueue, function (onRest) {\n            return onRest(cancel);\n          });\n        }\n      }\n    }\n  }, {\n    key: \"idle\",\n    get: function get() {\n      return !this.is(ACTIVE) && !this._state.asyncTo;\n    }\n  }, {\n    key: \"goal\",\n    get: function get() {\n      return getFluidValue(this.animation.to);\n    }\n  }, {\n    key: \"velocity\",\n    get: function get() {\n      var node = getAnimated(this);\n      return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map(function (node) {\n        return node.lastVelocity || 0;\n      });\n    }\n  }]);\n\n  return SpringValue;\n}(FrameValue);\n\nfunction checkDisposed(spring, name) {\n  if (spring.is(DISPOSED)) {\n    throw Error(\"Cannot call \\\"\" + name + \"\\\" of disposed \\\"\" + spring.constructor.name + \"\\\" object\");\n  }\n}\n/** Coerce an event prop to an event handler */\n\n\nfunction coerceEventProp(prop, key) {\n  return is.fun(prop) ? prop : key && prop ? prop[key] : undefined;\n}\n/**\n * The \"finished\" value is determined by each \"onRest\" handler,\n * based on whether the current value equals the goal value that\n * was calculated at the time the \"onRest\" handler was set.\n */\n\n\nvar checkFinishedOnRest = function checkFinishedOnRest(onRest, spring) {\n  var to = spring.animation.to;\n  return onRest ? function (cancel) {\n    if (cancel) {\n      onRest(getCancelledResult(spring));\n    } else {\n      var goal = computeGoal(to);\n      var value = computeGoal(spring.get());\n      var finished = isEqual(value, goal);\n      onRest(getFinishedResult(spring, finished));\n    }\n  } : noop;\n};\n\nfunction createLoopUpdate(props) {\n  var loop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : props.loop;\n  var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : props.to;\n  var loopRet = callProp(loop);\n\n  if (loopRet) {\n    var overrides = loopRet !== true && inferTo(loopRet);\n    var reverse = (overrides || props).reverse;\n    var reset = !overrides || overrides.reset;\n    return createUpdate(_extends(_extends({}, props), {}, {\n      loop,\n      // Avoid updating default props when looping.\n      default: false,\n      // For the \"reverse\" prop to loop as expected, the \"to\" prop\n      // must be undefined. The \"reverse\" prop is ignored when the\n      // \"to\" prop is an array or function.\n      to: !reverse || is.arr(to) || is.fun(to) ? to : undefined,\n      // Avoid defining the \"from\" prop if a reset is unwanted.\n      from: reset ? props.from : undefined,\n      reset\n    }, overrides));\n  }\n}\n/**\n * Return a new object based on the given `props`.\n *\n * - All unreserved props are moved into the `to` prop object.\n * - The `to` and `from` props are deleted when falsy.\n * - The `keys` prop is set to an array of affected keys,\n *   or `null` if all keys are affected.\n */\n\n\nfunction createUpdate(props) {\n  var _props = props = inferTo(props),\n      to = _props.to,\n      from = _props.from; // Collect the keys affected by this update.\n\n\n  var keys = new Set();\n\n  if (from) {\n    findDefined(from, keys);\n  } else {\n    // Falsy values are deleted to avoid merging issues.\n    delete props.from;\n  }\n\n  if (is.obj(to)) {\n    findDefined(to, keys);\n  } else if (!to) {\n    // Falsy values are deleted to avoid merging issues.\n    delete props.to;\n  } // The \"keys\" prop helps in applying updates to affected keys only.\n\n\n  props.keys = keys.size ? Array.from(keys) : null;\n  return props;\n}\n/**\n * A modified version of `createUpdate` meant for declarative APIs.\n */\n\n\nfunction declareUpdate(props) {\n  var update = createUpdate(props);\n\n  if (is.und(update.default)) {\n    update.default = getDefaultProps(update, [// Avoid forcing `immediate: true` onto imperative updates.\n    update.immediate === true && 'immediate']);\n  }\n\n  return update;\n}\n/** Find keys with defined values */\n\n\nfunction findDefined(values, keys) {\n  _each(values, function (value, key) {\n    return value != null && keys.add(key);\n  });\n}\n/** Events batched by the `Controller` class */\n\n\nvar BATCHED_EVENTS = ['onStart', 'onChange', 'onRest'];\nvar nextId$1 = 1;\n/** Queue of pending updates for a `Controller` instance. */\n\nvar Controller = /*#__PURE__*/function () {\n  /** The animated values */\n\n  /** The queue of props passed to the `update` method. */\n\n  /** Custom handler for flushing update queues */\n\n  /** These props are used by all future spring values */\n\n  /** The combined phase of our spring values */\n\n  /** The counter for tracking `scheduleProps` calls */\n\n  /** The values currently being animated */\n\n  /** State used by the `runAsync` function */\n\n  /** The event queues that are flushed once per frame maximum */\n  function Controller(props, flush) {\n    _classCallCheck(this, Controller);\n\n    this.id = nextId$1++;\n    this.springs = {};\n    this.queue = [];\n    this._flush = void 0;\n    this._initialProps = void 0;\n    this._phase = CREATED;\n    this._lastAsyncId = 0;\n    this._active = new Set();\n    this._state = {\n      pauseQueue: new Set(),\n      resumeQueue: new Set()\n    };\n    this._events = {\n      onStart: new Set(),\n      onChange: new Set(),\n      onRest: new Map()\n    };\n    this._onFrame = this._onFrame.bind(this);\n\n    if (flush) {\n      this._flush = flush;\n    }\n\n    if (props) {\n      this.start(props);\n    }\n  }\n  /**\n   * Equals `true` when no spring values are in the frameloop, and\n   * no async animation is currently active.\n   */\n\n\n  _createClass(Controller, [{\n    key: \"is\",\n\n    /** Check the current phase */\n    value: function is(phase) {\n      return this._phase == phase;\n    }\n    /** Get the current values of our springs */\n\n  }, {\n    key: \"get\",\n    value: function get() {\n      var values = {};\n      this.each(function (spring, key) {\n        return values[key] = spring.get();\n      });\n      return values;\n    }\n    /** Push an update onto the queue of each value. */\n\n  }, {\n    key: \"update\",\n    value: function update(props) {\n      if (props) this.queue.push(createUpdate(props));\n      return this;\n    }\n    /**\n     * Start the queued animations for every spring, and resolve the returned\n     * promise once all queued animations have finished or been cancelled.\n     *\n     * When you pass a queue (instead of nothing), that queue is used instead of\n     * the queued animations added with the `update` method, which are left alone.\n     */\n\n  }, {\n    key: \"start\",\n    value: function start(props) {\n      var queue = props ? toArray(props).map(createUpdate) : this.queue;\n\n      if (!props) {\n        this.queue = [];\n      }\n\n      if (this._flush) {\n        return this._flush(this, queue);\n      }\n\n      prepareKeys(this, queue);\n      return flushUpdateQueue(this, queue);\n    }\n    /** Stop one animation, some animations, or all animations */\n\n  }, {\n    key: \"stop\",\n    value: function stop(keys) {\n      if (is.und(keys)) {\n        this.each(function (spring) {\n          return spring.stop();\n        });\n        cancelAsync(this._state, this._lastAsyncId);\n      } else {\n        var springs = this.springs;\n\n        _each(toArray(keys), function (key) {\n          return springs[key].stop();\n        });\n      }\n\n      return this;\n    }\n    /** Freeze the active animation in time */\n\n  }, {\n    key: \"pause\",\n    value: function pause(keys) {\n      if (is.und(keys)) {\n        this.each(function (spring) {\n          return spring.pause();\n        });\n      } else {\n        var springs = this.springs;\n\n        _each(toArray(keys), function (key) {\n          return springs[key].pause();\n        });\n      }\n\n      return this;\n    }\n    /** Resume the animation if paused. */\n\n  }, {\n    key: \"resume\",\n    value: function resume(keys) {\n      if (is.und(keys)) {\n        this.each(function (spring) {\n          return spring.resume();\n        });\n      } else {\n        var springs = this.springs;\n\n        _each(toArray(keys), function (key) {\n          return springs[key].resume();\n        });\n      }\n\n      return this;\n    }\n    /** Restart every animation. */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.each(function (spring) {\n        return spring.reset();\n      }); // TODO: restart async \"to\" prop\n\n      return this;\n    }\n    /** Call a function once per spring value */\n\n  }, {\n    key: \"each\",\n    value: function each(iterator) {\n      _each(this.springs, iterator);\n    }\n    /** Destroy every spring in this controller */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this._state.asyncTo = undefined;\n      this.each(function (spring) {\n        return spring.dispose();\n      });\n      this.springs = {};\n    }\n    /** @internal Called at the end of every animation frame */\n\n  }, {\n    key: \"_onFrame\",\n    value: function _onFrame() {\n      var _this10 = this;\n\n      var _this$_events = this._events,\n          onStart = _this$_events.onStart,\n          onChange = _this$_events.onChange,\n          onRest = _this$_events.onRest;\n      var isActive = this._active.size > 0;\n\n      if (isActive && this._phase != ACTIVE) {\n        this._phase = ACTIVE;\n        flush(onStart, function (onStart) {\n          return onStart(_this10);\n        });\n      }\n\n      var values = (onChange.size || !isActive && onRest.size) && this.get();\n      flush(onChange, function (onChange) {\n        return onChange(values);\n      }); // The \"onRest\" queue is only flushed when all springs are idle.\n\n      if (!isActive) {\n        this._phase = IDLE;\n        flush(onRest, function (_ref8) {\n          var _ref9 = _slicedToArray(_ref8, 2),\n              onRest = _ref9[0],\n              result = _ref9[1];\n\n          result.value = values;\n          onRest(result);\n        });\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"onParentChange\",\n    value: function onParentChange(event) {\n      if (event.type == 'change') {\n        this._active[event.idle ? 'delete' : 'add'](event.parent);\n\n        frameLoop.onFrame(this._onFrame);\n      }\n    }\n  }, {\n    key: \"idle\",\n    get: function get() {\n      return !this._state.asyncTo && Object.values(this.springs).every(function (spring) {\n        return spring.idle;\n      });\n    }\n  }]);\n\n  return Controller;\n}();\n/**\n * Warning: Props might be mutated.\n */\n\n\nfunction flushUpdateQueue(ctrl, queue) {\n  return Promise.all(queue.map(function (props) {\n    return flushUpdate(ctrl, props);\n  })).then(function (results) {\n    return getCombinedResult(ctrl, results);\n  });\n}\n/**\n * Warning: Props might be mutated.\n *\n * Process a single set of props using the given controller.\n *\n * The returned promise resolves to `true` once the update is\n * applied and any animations it starts are finished without being\n * stopped or cancelled.\n */\n\n\nfunction flushUpdate(ctrl, props, isLoop) {\n  var to = props.to,\n      loop = props.loop,\n      onRest = props.onRest; // Looping must be handled in this function, or else the values\n  // would end up looping out-of-sync in many common cases.\n\n  if (loop) {\n    props.loop = false;\n  }\n\n  var asyncTo = is.arr(to) || is.fun(to) ? to : undefined;\n\n  if (asyncTo) {\n    props.to = undefined;\n    props.onRest = undefined;\n  } else {\n    // For certain events, use batching to prevent multiple calls per frame.\n    // However, batching is avoided when the `to` prop is async, because any\n    // event props are used as default props instead.\n    _each(BATCHED_EVENTS, function (key) {\n      var handler = props[key];\n\n      if (is.fun(handler)) {\n        var queue = ctrl['_events'][key];\n\n        if (queue instanceof Set) {\n          props[key] = function () {\n            return queue.add(handler);\n          };\n        } else {\n          props[key] = function (_ref10) {\n            var finished = _ref10.finished,\n                cancelled = _ref10.cancelled;\n            var result = queue.get(handler);\n\n            if (result) {\n              if (!finished) result.finished = false;\n              if (cancelled) result.cancelled = true;\n            } else {\n              // The \"value\" is set before the \"handler\" is called.\n              queue.set(handler, {\n                value: null,\n                finished,\n                cancelled\n              });\n            }\n          };\n        }\n      }\n    });\n  }\n\n  var keys = props.keys || Object.keys(ctrl.springs);\n  var promises = keys.map(function (key) {\n    return ctrl.springs[key].start(props);\n  }); // Schedule the \"asyncTo\" if defined.\n\n  var state = ctrl['_state'];\n\n  if (asyncTo) {\n    promises.push(scheduleProps(++ctrl['_lastAsyncId'], {\n      props,\n      state,\n      actions: {\n        pause: noop,\n        resume: noop,\n\n        start(props, resolve) {\n          props.onRest = onRest;\n\n          if (!props.cancel) {\n            resolve(runAsync(asyncTo, props, state, ctrl));\n          } // Prevent `cancel: true` from ending the current `runAsync` call,\n          // except when the default `cancel` prop is being set.\n          else if (hasDefaultProp(props, 'cancel')) {\n              cancelAsync(state, props.callId);\n            }\n        }\n\n      }\n    }));\n  } // Respect the `cancel` prop when no keys are affected.\n  else if (!props.keys && props.cancel === true) {\n      cancelAsync(state, ctrl['_lastAsyncId']);\n    }\n\n  return Promise.all(promises).then(function (results) {\n    var result = getCombinedResult(ctrl, results);\n\n    if (loop && result.finished && !(isLoop && result.noop)) {\n      var nextProps = createLoopUpdate(props, loop, to);\n\n      if (nextProps) {\n        prepareKeys(ctrl, [nextProps]);\n        return flushUpdate(ctrl, nextProps, true);\n      }\n    }\n\n    return result;\n  });\n}\n/**\n * From an array of updates, get the map of `SpringValue` objects\n * by their keys. Springs are created when any update wants to\n * animate a new key.\n *\n * Springs created by `getSprings` are neither cached nor observed\n * until they're given to `setSprings`.\n */\n\n\nfunction getSprings(ctrl, props) {\n  var springs = _extends({}, ctrl.springs);\n\n  if (props) {\n    _each(toArray(props), function (props) {\n      if (is.und(props.keys)) {\n        props = createUpdate(props);\n      }\n\n      if (!is.obj(props.to)) {\n        // Avoid passing array/function to each spring.\n        props = _extends(_extends({}, props), {}, {\n          to: undefined\n        });\n      }\n\n      prepareSprings(springs, props, function (key) {\n        return createSpring(key);\n      });\n    });\n  }\n\n  return springs;\n}\n/**\n * Tell a controller to manage the given `SpringValue` objects\n * whose key is not already in use.\n */\n\n\nfunction setSprings(ctrl, springs) {\n  _each(springs, function (spring, key) {\n    if (!ctrl.springs[key]) {\n      ctrl.springs[key] = spring;\n      spring.addChild(ctrl);\n    }\n  });\n}\n\nfunction createSpring(key, observer) {\n  var spring = new SpringValue();\n  spring.key = key;\n\n  if (observer) {\n    spring.addChild(observer);\n  }\n\n  return spring;\n}\n/**\n * Ensure spring objects exist for each defined key.\n *\n * Using the `props`, the `Animated` node of each `SpringValue` may\n * be created or updated.\n */\n\n\nfunction prepareSprings(springs, props, create) {\n  if (props.keys) {\n    _each(props.keys, function (key) {\n      var spring = springs[key] || (springs[key] = create(key));\n      spring['_prepareNode'](props);\n    });\n  }\n}\n/**\n * Ensure spring objects exist for each defined key, and attach the\n * `ctrl` to them for observation.\n *\n * The queue is expected to contain `createUpdate` results.\n */\n\n\nfunction prepareKeys(ctrl, queue) {\n  _each(queue, function (props) {\n    prepareSprings(ctrl.springs, props, function (key) {\n      return createSpring(key, ctrl);\n    });\n  });\n}\n/**\n * This context affects all new and existing `SpringValue` objects\n * created with the hook API or the renderprops API.\n */\n\n\nvar ctx = createContext({});\n\nvar SpringContext = function SpringContext(_ref) {\n  var children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  var inherited = useContext(ctx); // Memoize the context to avoid unwanted renders.\n\n  props = useMemo(function () {\n    return _extends(_extends({}, inherited), props);\n  }, [inherited, props.pause, props.cancel, props.immediate, props.config]);\n  var Provider = ctx.Provider;\n  return /*#__PURE__*/createElement(Provider, {\n    value: props\n  }, children);\n};\n\nSpringContext.Provider = ctx.Provider;\nSpringContext.Consumer = ctx.Consumer;\n/** Get the current values of nearest `SpringContext` component. */\n\nvar useSpringContext = function useSpringContext() {\n  return useContext(ctx);\n};\n/** Create an imperative API for manipulating an array of `Controller` objects. */\n\n\nvar SpringHandle = {\n  create: function create(getControllers) {\n    return {\n      get controllers() {\n        return getControllers();\n      },\n\n      update(props) {\n        _each(getControllers(), function (ctrl, i) {\n          ctrl.update(getProps(props, i, ctrl));\n        });\n\n        return this;\n      },\n\n      start(props) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n          var results;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.next = 2;\n                  return Promise.all(getControllers().map(function (ctrl, i) {\n                    var update = getProps(props, i, ctrl);\n                    return ctrl.start(update);\n                  }));\n\n                case 2:\n                  results = _context2.sent;\n                  return _context2.abrupt(\"return\", {\n                    value: results.map(function (result) {\n                      return result.value;\n                    }),\n                    finished: results.every(function (result) {\n                      return result.finished;\n                    })\n                  });\n\n                case 4:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }))();\n      },\n\n      stop: function stop(keys) {\n        return _each(getControllers(), function (ctrl) {\n          return ctrl.stop(keys);\n        });\n      },\n      pause: function pause(keys) {\n        return _each(getControllers(), function (ctrl) {\n          return ctrl.pause(keys);\n        });\n      },\n      resume: function resume(keys) {\n        return _each(getControllers(), function (ctrl) {\n          return ctrl.resume(keys);\n        });\n      }\n    };\n  }\n};\n/** @internal */\n\nfunction useSprings(length, props, deps) {\n  var propsFn = is.fun(props) && props;\n  if (propsFn && !deps) deps = []; // Set to 0 to prevent sync flush.\n\n  var layoutId = useRef(0);\n  var forceUpdate = useForceUpdate(); // State is updated on commit.\n\n  var _useState = useState(function () {\n    return {\n      ctrls: [],\n      queue: [],\n\n      flush(ctrl, updates) {\n        var springs = getSprings(ctrl, updates); // Flushing is postponed until the component's commit phase\n        // if a spring was created since the last commit.\n\n        var canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs).some(function (key) {\n          return !ctrl.springs[key];\n        });\n        return canFlushSync ? flushUpdateQueue(ctrl, updates) : new Promise(function (resolve) {\n          setSprings(ctrl, springs);\n          state.queue.push(function () {\n            resolve(flushUpdateQueue(ctrl, updates));\n          });\n          forceUpdate();\n        });\n      }\n\n    };\n  }),\n      _useState2 = _slicedToArray(_useState, 1),\n      state = _useState2[0]; // The imperative API ref from the props of the first controller.\n\n\n  var refProp = useRef();\n\n  var ctrls = _toConsumableArray(state.ctrls);\n\n  var updates = []; // Cache old controllers to dispose in the commit phase.\n\n  var prevLength = usePrev(length) || 0;\n  var disposed = ctrls.slice(length, prevLength); // Create new controllers when \"length\" increases, and destroy\n  // the affected controllers when \"length\" decreases.\n\n  useMemo(function () {\n    ctrls.length = length;\n    declareUpdates(prevLength, length);\n  }, [length]); // Update existing controllers when \"deps\" are changed.\n\n  useMemo(function () {\n    declareUpdates(0, Math.min(prevLength, length));\n  }, deps);\n  /** Fill the `updates` array with declarative updates for the given index range. */\n\n  function declareUpdates(startIndex, endIndex) {\n    for (var i = startIndex; i < endIndex; i++) {\n      var ctrl = ctrls[i] || (ctrls[i] = new Controller(null, state.flush));\n\n      var _update2 = propsFn ? propsFn(i, ctrl) : props[i];\n\n      if (_update2) {\n        _update2 = updates[i] = declareUpdate(_update2);\n\n        if (i == 0) {\n          refProp.current = _update2.ref;\n          _update2.ref = undefined;\n        }\n      }\n    }\n  }\n\n  var api = useMemo$1(function () {\n    return SpringHandle.create(function () {\n      return state.ctrls;\n    });\n  }, []); // New springs are created during render so users can pass them to\n  // their animated components, but new springs aren't cached until the\n  // commit phase (see the `useLayoutEffect` callback below).\n\n  var springs = ctrls.map(function (ctrl, i) {\n    return getSprings(ctrl, updates[i]);\n  });\n  var context = useSpringContext();\n  useLayoutEffect(function () {\n    layoutId.current++; // Replace the cached controllers.\n\n    state.ctrls = ctrls; // Update the ref prop.\n\n    if (refProp.current) {\n      refProp.current.current = api;\n    } // Flush the commit queue.\n\n\n    var queue = state.queue;\n\n    if (queue.length) {\n      state.queue = [];\n\n      _each(queue, function (cb) {\n        return cb();\n      });\n    } // Dispose unused controllers.\n\n\n    _each(disposed, function (ctrl) {\n      return ctrl.dispose();\n    }); // Update existing controllers.\n\n\n    _each(ctrls, function (ctrl, i) {\n      var values = springs[i];\n      setSprings(ctrl, values); // Update the default props.\n\n      ctrl.start({\n        default: context\n      }); // Apply updates created during render.\n\n      var update = updates[i];\n\n      if (update) {\n        // Start animating unless a ref exists.\n        if (refProp.current) {\n          ctrl.queue.push(update);\n        } else {\n          ctrl.start(update);\n        }\n      }\n    });\n  }); // Dispose all controllers on unmount.\n\n  useOnce(function () {\n    return function () {\n      _each(state.ctrls, function (ctrl) {\n        return ctrl.dispose();\n      });\n    };\n  }); // Return a deep copy of the `springs` array so the caller can\n  // safely mutate it during render.\n\n  var values = springs.map(function (x) {\n    return _extends({}, x);\n  });\n  return propsFn || arguments.length == 3 ? [values, api.start, api.stop] : values;\n}\n/**\n * The props that `useSpring` recognizes.\n */\n\n/** @internal */\n\n\nfunction useSpring(props, deps) {\n  var isFn = is.fun(props);\n\n  var _useSprings = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps),\n      _useSprings2 = _slicedToArray(_useSprings, 3),\n      _useSprings2$ = _slicedToArray(_useSprings2[0], 1),\n      values = _useSprings2$[0],\n      update = _useSprings2[1],\n      stop = _useSprings2[2];\n\n  return isFn || arguments.length == 2 ? [values, update, stop] : values;\n}\n\nfunction useTrail(length, propsArg, deps) {\n  var propsFn = is.fun(propsArg) && propsArg;\n  if (propsFn && !deps) deps = [];\n  var ctrls = [];\n  var result = useSprings(length, function (i, ctrl) {\n    ctrls[i] = ctrl;\n    return getProps(propsArg, i, ctrl);\n  }, // Ensure the props function is called when no deps exist.\n  // This works around the 3 argument rule.\n  deps || [{}]);\n  useLayoutEffect(function () {\n    var reverse = is.obj(propsArg) && propsArg.reverse;\n\n    for (var i = 0; i < ctrls.length; i++) {\n      var parent = ctrls[i + (reverse ? 1 : -1)];\n      if (parent) ctrls[i].update({\n        to: parent.springs\n      }).start();\n    }\n  }, deps);\n\n  if (propsFn || arguments.length == 3) {\n    var _update3 = result[1];\n    result[1] = useCallbackOne(function (propsArg) {\n      var reverse = is.obj(propsArg) && propsArg.reverse;\n      return _update3(function (i, ctrl) {\n        var props = getProps(propsArg, i, ctrl);\n        var parent = ctrls[i + (reverse ? 1 : -1)];\n        if (parent) props.to = parent.springs;\n        return props;\n      });\n    }, deps);\n    return result;\n  }\n\n  return result[0];\n} // TODO: convert to \"const enum\" once Babel supports it\n\n/** This transition is being mounted */\n\n\nvar MOUNT = 'mount';\n/** This transition is entering or has entered */\n\nvar ENTER = 'enter';\n/** This transition had its animations updated */\n\nvar UPDATE = 'update';\n/** This transition will expire after animating */\n\nvar LEAVE = 'leave';\n\nfunction useTransition(data, props, deps) {\n  var ref = props.ref,\n      reset = props.reset,\n      sort = props.sort,\n      _props$trail = props.trail,\n      trail = _props$trail === void 0 ? 0 : _props$trail,\n      _props$expires = props.expires,\n      expires = _props$expires === void 0 ? true : _props$expires; // Every item has its own transition.\n\n  var items = toArray(data);\n  var transitions = []; // Keys help with reusing transitions between renders.\n  // The `key` prop can be undefined (which means the items themselves are used\n  // as keys), or a function (which maps each item to its key), or an array of\n  // keys (which are assigned to each item by index).\n\n  var keys = getKeys(items, props); // The \"onRest\" callbacks need a ref to the latest transitions.\n\n  var usedTransitions = useRef(null);\n  var prevTransitions = reset ? null : usedTransitions.current;\n  useLayoutEffect(function () {\n    usedTransitions.current = transitions;\n  }); // Destroy all transitions on dismount.\n\n  useOnce(function () {\n    return function () {\n      return _each(usedTransitions.current, function (t) {\n        if (t.expired) {\n          clearTimeout(t.expirationId);\n        }\n\n        t.ctrl.dispose();\n      });\n    };\n  }); // Map old indices to new indices.\n\n  var reused = [];\n  if (prevTransitions) _each(prevTransitions, function (t, i) {\n    // Expired transitions are not rendered.\n    if (t.expired) {\n      clearTimeout(t.expirationId);\n    } else {\n      i = reused[i] = keys.indexOf(t.key);\n      if (~i) transitions[i] = t;\n    }\n  }); // Mount new items with fresh transitions.\n\n  _each(items, function (item, i) {\n    transitions[i] || (transitions[i] = {\n      key: keys[i],\n      item,\n      phase: MOUNT,\n      ctrl: new Controller()\n    });\n  }); // Update the item of any transition whose key still exists,\n  // and ensure leaving transitions are rendered until they finish.\n\n\n  if (reused.length) {\n    var i = -1;\n\n    _each(reused, function (keyIndex, prevIndex) {\n      var t = prevTransitions[prevIndex];\n\n      if (~keyIndex) {\n        i = transitions.indexOf(t);\n        transitions[i] = _extends(_extends({}, t), {}, {\n          item: items[keyIndex]\n        });\n      } else if (props.leave) {\n        transitions.splice(++i, 0, t);\n      }\n    });\n  }\n\n  if (is.fun(sort)) {\n    transitions.sort(function (a, b) {\n      return sort(a.item, b.item);\n    });\n  } // Track cumulative delay for the \"trail\" prop.\n\n\n  var delay = -trail; // Expired transitions use this to dismount.\n\n  var forceUpdate = useForceUpdate(); // These props are inherited by every phase change.\n\n  var defaultProps = getDefaultProps(props); // Generate changes to apply in useEffect.\n\n  var changes = new Map();\n\n  _each(transitions, function (t, i) {\n    var key = t.key;\n    var prevPhase = t.phase;\n    var to;\n    var phase;\n\n    if (prevPhase == MOUNT) {\n      to = props.enter;\n      phase = ENTER;\n    } else {\n      var isLeave = keys.indexOf(key) < 0;\n\n      if (prevPhase != LEAVE) {\n        if (isLeave) {\n          to = props.leave;\n          phase = LEAVE;\n        } else if (to = props.update) {\n          phase = UPDATE;\n        } else return;\n      } else if (!isLeave) {\n        to = props.enter;\n        phase = ENTER;\n      } else return;\n    } // When \"to\" is a function, it can return (1) an array of \"useSpring\" props,\n    // (2) an async function, or (3) an object with any \"useSpring\" props.\n\n\n    to = callProp(to, t.item, i);\n    to = is.obj(to) ? inferTo(to) : {\n      to\n    };\n\n    if (!to.config) {\n      var _config2 = props.config || defaultProps.config;\n\n      to.config = callProp(_config2, t.item, i);\n    } // The payload is used to update the spring props once the current render is committed.\n\n\n    var payload = _extends(_extends({}, defaultProps), {}, {\n      delay: delay += trail,\n      // This prevents implied resets.\n      reset: false\n    }, to);\n\n    if (phase == ENTER && is.und(payload.from)) {\n      // The `initial` prop is used on the first render of our parent component,\n      // as well as when `reset: true` is passed. It overrides the `from` prop\n      // when defined, and it makes `enter` instant when null.\n      var from = is.und(props.initial) || prevTransitions ? props.from : props.initial;\n      payload.from = callProp(from, t.item, i);\n    }\n\n    var onRest = payload.onRest;\n\n    payload.onRest = function (result) {\n      var transitions = usedTransitions.current;\n      var t = transitions.find(function (t) {\n        return t.key === key;\n      });\n      if (!t) return;\n\n      if (is.fun(onRest)) {\n        onRest(result, t);\n      } // Reset the phase of a cancelled enter/leave transition, so it can\n      // retry the animation on the next render.\n\n\n      if (result.cancelled && t.phase != UPDATE) {\n        t.phase = prevPhase;\n        return;\n      }\n\n      if (t.ctrl.idle) {\n        var idle = transitions.every(function (t) {\n          return t.ctrl.idle;\n        });\n\n        if (t.phase == LEAVE) {\n          var expiry = callProp(expires, t.item);\n\n          if (expiry !== false) {\n            var expiryMs = expiry === true ? 0 : expiry;\n            t.expired = true; // Force update once the expiration delay ends.\n\n            if (!idle && expiryMs > 0) {\n              // The maximum timeout is 2^31-1\n              if (expiryMs <= 0x7fffffff) t.expirationId = setTimeout(forceUpdate, expiryMs);\n              return;\n            }\n          }\n        } // Force update once idle and expired items exist.\n\n\n        if (idle && transitions.some(function (t) {\n          return t.expired;\n        })) {\n          forceUpdate();\n        }\n      }\n    };\n\n    var springs = getSprings(t.ctrl, payload);\n    changes.set(t, {\n      phase,\n      springs,\n      payload\n    });\n  }); // The prop overrides from an ancestor.\n\n\n  var context = useSpringContext(); // Merge the context into each transition.\n\n  useLayoutEffect(function () {\n    _each(transitions, function (t) {\n      t.ctrl.start({\n        default: context\n      });\n    });\n  }, [context]);\n  var api = useMemo$1(function () {\n    return SpringHandle.create(function () {\n      return usedTransitions.current.map(function (t) {\n        return t.ctrl;\n      });\n    });\n  }, []);\n  useImperativeHandle(ref, function () {\n    return api;\n  });\n  useLayoutEffect(function () {\n    _each(changes, function (_ref11, t) {\n      var phase = _ref11.phase,\n          springs = _ref11.springs,\n          payload = _ref11.payload;\n      setSprings(t.ctrl, springs);\n\n      if (!context.cancel) {\n        t.phase = phase;\n\n        if (phase == ENTER) {\n          t.ctrl.start({\n            default: context\n          });\n        }\n\n        t.ctrl[ref ? 'update' : 'start'](payload);\n      }\n    });\n  }, reset ? void 0 : deps);\n\n  var renderTransitions = function renderTransitions(render) {\n    return /*#__PURE__*/createElement(Fragment, null, transitions.map(function (t, i) {\n      var _ref12 = changes.get(t) || t.ctrl,\n          springs = _ref12.springs;\n\n      var elem = render(_extends({}, springs), t.item, t, i);\n      return elem && elem.type ? /*#__PURE__*/createElement(elem.type, _extends({}, elem.props, {\n        key: is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id,\n        ref: elem.ref\n      })) : elem;\n    }));\n  };\n\n  return arguments.length == 3 ? [renderTransitions, api.start, api.stop] : renderTransitions;\n}\n\nfunction getKeys(items, _ref13) {\n  var key = _ref13.key,\n      _ref13$keys = _ref13.keys,\n      keys = _ref13$keys === void 0 ? key : _ref13$keys;\n  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);\n}\n/**\n * The `Spring` component passes `SpringValue` objects to your render prop.\n */\n\n\nfunction Spring(_ref) {\n  var children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  return children(useSpring(props));\n}\n\nfunction Trail(_ref) {\n  var items = _ref.items,\n      children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"items\", \"children\"]);\n\n  var trails = useTrail(items.length, props);\n  return items.map(function (item, index) {\n    var result = children(item, index);\n    return is.fun(result) ? result(trails[index]) : result;\n  });\n}\n\nfunction Transition(_ref) {\n  var items = _ref.items,\n      children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"items\", \"children\"]);\n\n  return /*#__PURE__*/createElement(Fragment, null, useTransition(items, props)(children));\n}\n/**\n * An `Interpolation` is a memoized value that's computed whenever one of its\n * `FluidValue` dependencies has its value changed.\n *\n * Other `FrameValue` objects can depend on this. For example, passing an\n * `Interpolation` as the `to` prop of a `useSpring` call will trigger an\n * animation toward the memoized value.\n */\n\n\nvar Interpolation = /*#__PURE__*/function (_FrameValue2) {\n  _inherits(Interpolation, _FrameValue2);\n\n  var _super4 = _createSuper(Interpolation);\n\n  /** Useful for debugging. */\n\n  /** Equals false when in the frameloop */\n\n  /** The function that maps inputs values to output */\n  function Interpolation(source, args) {\n    var _this11;\n\n    _classCallCheck(this, Interpolation);\n\n    _this11 = _super4.call(this);\n    _this11.source = source;\n    _this11.key = void 0;\n    _this11.idle = true;\n    _this11.calc = void 0;\n    _this11.calc = createInterpolator.apply(void 0, _toConsumableArray(args));\n\n    var value = _this11._get();\n\n    var nodeType = is.arr(value) ? AnimatedArray : AnimatedValue; // Assume the computed value never changes type.\n\n    setAnimated(_assertThisInitialized(_this11), nodeType.create(value));\n    return _this11;\n  }\n\n  _createClass(Interpolation, [{\n    key: \"advance\",\n    value: function advance(_dt) {\n      var value = this._get();\n\n      var oldValue = this.get();\n\n      if (!isEqual(value, oldValue)) {\n        getAnimated(this).setValue(value);\n\n        this._onChange(value, this.idle);\n      }\n    }\n  }, {\n    key: \"_get\",\n    value: function _get() {\n      var inputs = is.arr(this.source) ? this.source.map(function (node) {\n        return node.get();\n      }) : toArray(this.source.get());\n      return this.calc.apply(this, _toConsumableArray(inputs));\n    }\n  }, {\n    key: \"_reset\",\n    value: function _reset() {\n      _each(getPayload(this), function (node) {\n        return node.reset();\n      });\n\n      _get(_getPrototypeOf(Interpolation.prototype), \"_reset\", this).call(this);\n    }\n  }, {\n    key: \"_start\",\n    value: function _start() {\n      this.idle = false;\n\n      _get(_getPrototypeOf(Interpolation.prototype), \"_start\", this).call(this);\n\n      if (skipAnimation) {\n        this.idle = true;\n        this.advance();\n      } else {\n        frameLoop.start(this);\n      }\n    }\n  }, {\n    key: \"_attach\",\n    value: function _attach() {\n      var _this12 = this;\n\n      // Start observing our \"source\" once we have an observer.\n      var idle = true;\n      var priority = 1;\n\n      _each(toArray(this.source), function (source) {\n        if (isFrameValue(source)) {\n          if (!source.idle) idle = false;\n          priority = Math.max(priority, source.priority + 1);\n        }\n\n        source.addChild(_this12);\n      });\n\n      this.priority = priority;\n\n      if (!idle) {\n        this._reset();\n\n        this._start();\n      }\n    }\n  }, {\n    key: \"_detach\",\n    value: function _detach() {\n      var _this13 = this;\n\n      // Stop observing our \"source\" once we have no observers.\n      _each(toArray(this.source), function (source) {\n        source.removeChild(_this13);\n      }); // This removes us from the frameloop.\n\n\n      this.idle = true;\n    }\n    /** @internal */\n\n  }, {\n    key: \"onParentChange\",\n    value: function onParentChange(event) {\n      // Ensure our start value respects our parent values, in case\n      // any of their animations were restarted with the \"reset\" prop.\n      if (event.type == 'start') {\n        this.advance();\n      } // Change events are useful for (1) reacting to non-animated parents\n      // and (2) reacting to the last change in a parent animation.\n      else if (event.type == 'change') {\n          // If we're idle, we know for sure that this change is *not*\n          // caused by an animation.\n          if (this.idle) {\n            this.advance();\n          } // Leave the frameloop when all parents are done animating.\n          else if (event.idle) {\n              this.idle = toArray(this.source).every(function (source) {\n                return source.idle !== false;\n              });\n\n              if (this.idle) {\n                this.advance();\n\n                _each(getPayload(this), function (node) {\n                  node.done = true;\n                });\n              }\n            }\n        } // Ensure our priority is greater than all parents, which means\n        // our value won't be updated until our parents have updated.\n        else if (event.type == 'priority') {\n            this.priority = toArray(this.source).reduce(function (max, source) {\n              return Math.max(max, (source.priority || 0) + 1);\n            }, 0);\n          }\n\n      _get(_getPrototypeOf(Interpolation.prototype), \"onParentChange\", this).call(this, event);\n    }\n  }]);\n\n  return Interpolation;\n}(FrameValue);\n/** Map the value of one or more dependencies */\n\n\nvar to = function to(source) {\n  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    args[_key5 - 1] = arguments[_key5];\n  }\n\n  return new Interpolation(source, args);\n};\n/** @deprecated Use the `to` export instead */\n\n\nvar interpolate = function interpolate(source) {\n  for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    args[_key6 - 1] = arguments[_key6];\n  }\n\n  return deprecateInterpolate(), new Interpolation(source, args);\n};\n/** Extract the raw value types that are being interpolated */\n\n\nGlobals.assign({\n  createStringInterpolator: createStringInterpolator$1,\n  to: function to(source, args) {\n    return new Interpolation(source, args);\n  }\n});\n/** Advance all animations forward one frame */\n\nvar update = function update() {\n  return Globals.frameLoop.advance();\n};\n\nexport { BailSignal, Controller, FrameValue, Interpolation, Spring, SpringContext, SpringHandle, SpringValue, Trail, Transition, config, inferTo, interpolate, to, update, useChain, useSpring, useSprings, useTrail, useTransition };","map":{"version":3,"sources":["src/hooks/useChain.js","src/constants.ts","src/AnimationConfig.ts","src/Animation.ts","src/helpers.ts","src/scheduleProps.ts","src/AnimationResult.ts","src/runAsync.ts","src/FrameValue.ts","src/SpringPhase.ts","src/SpringValue.ts","src/Controller.ts","src/SpringContext.tsx","src/SpringHandle.ts","src/hooks/useSprings.ts","src/hooks/useSpring.ts","src/hooks/useTrail.ts","src/TransitionPhase.ts","src/hooks/useTransition.tsx","src/components/Spring.tsx","src/components/Trail.tsx","src/components/Transition.tsx","src/Interpolation.ts","src/interpolate.ts","src/globals.ts"],"names":["timeFrame","useLayoutEffect","prevDelay","each","ref","controllers","delay","timeSteps","isNaN","ctrl","props","p","Promise","start","updates","q","config","default","tension","friction","gentle","wobbly","stiff","slow","molasses","linear","t","defaults","configs","mass","damping","easing","clamp","frequency","velocity","restVelocity","precision","progress","duration","bounce","decay","round","constructor","Object","defaultConfig","sanitizeConfig","newConfig","is","Math","isTensionConfig","emptyArray","useMemo","useMemoOne","deps","value","matchProp","key","toArray","getProps","hasDefaultProp","getDefaultProp","getDefaultProps","omitKeys","keys","mergeDefaultProps","DEFAULT_PROPS","RESERVED_PROPS","from","to","loop","reset","pause","cancel","reverse","immediate","onDelayEnd","onProps","onStart","onChange","onRest","items","trail","sort","expires","initial","enter","update","leave","children","callId","parentId","forward","count","getForwardProps","out","getFluidConfig","computeGoal","range","output","actions","callProp","state","onResume","timeout","G","reject","getCombinedResult","results","result","getCancelledResult","getNoopResult","getFinishedResult","target","noop","finished","cancelled","resume","asyncTo","promise","prevPromise","defaultProps","bailPromise","preventBail","bail","withBailHandler","fn","onError","err","bailIfEnded","bailSignal","bailResult","animate","arg1","animating","isFrameValue","nextId","node","getAnimated","deprecateInterpolate","type","parent","idle","priority","Array","child","CREATED","IDLE","ACTIVE","PAUSED","DISPOSED","animation","queue","_phase","_state","pauseQueue","resumeQueue","_defaultProps","_lastCallId","_lastToId","getFluidValue","changed","anim","toValues","payload","getPayload","toConfig","position","elapsed","v0","e","bounceFactor","canBounce","isGrowing","isBouncing","step","numSteps","dt","n","isMoving","springForce","dampingForce","acceleration","Number","console","checkDisposed","flush","onPause","cancelAsync","event","nodeType","setAnimated","parentNode","isAnimatedString","mergeDefaultProp","isLoop","nextProps","createLoopUpdate","resolve","hasToProp","hasFromProp","get","prop","coerceEventProp","prevFrom","hasFromChanged","isEqual","hasToChanged","fromConfig","hasAsyncTo","mergeConfig","goal","isAnimatable","Error","goalType","started","hasValueChanged","onRestQueue","checkFinishedOnRest","onRestIndex","runAsync","oldValue","spring","loopRet","overrides","inferTo","createUpdate","findDefined","BATCHED_EVENTS","id","springs","_flush","_initialProps","_lastAsyncId","_active","_events","values","prepareKeys","flushUpdateQueue","isActive","flushUpdate","handler","promises","scheduleProps","undefined","prepareSprings","createSpring","create","ctx","React","SpringContext","inherited","useContext","Provider","useSpringContext","SpringHandle","getControllers","stop","propsFn","layoutId","useRef","forceUpdate","useForceUpdate","useState","ctrls","getSprings","canFlushSync","setSprings","refProp","prevLength","usePrev","disposed","declareUpdates","i","declareUpdate","api","context","cb","useOnce","x","arguments","isFn","useSprings","propsArg","useCallbackOne","MOUNT","ENTER","UPDATE","LEAVE","transitions","getKeys","usedTransitions","prevTransitions","clearTimeout","reused","phase","item","a","b","changes","prevPhase","isLeave","expiry","expiryMs","setTimeout","useImperativeHandle","renderTransitions","render","elem","useSpring","trails","useTrail","React.createElement","useTransition","calc","source","createInterpolator","inputs","interpolate","Globals","createStringInterpolator"],"mappings":"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","sourcesContent":["import { useLayoutEffect } from 'react-layout-effect';\nimport { each, is, toArray, isAnimatedString, getFluidConfig, Globals, FluidValue, getFluidValue, flush, isEqual, noop, useForceUpdate, usePrev, useOnce, createInterpolator } from '@react-spring/shared';\nexport { FrameLoop, Globals, createInterpolator } from '@react-spring/shared';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { createContext, useContext, createElement, useRef, useState, useMemo as useMemo$1, useImperativeHandle, Fragment } from 'react';\nimport { getAnimated, AnimatedValue, getPayload, setAnimated, AnimatedArray, AnimatedString } from '@react-spring/animated';\nimport { createStringInterpolator, batchedUpdates, to as to$1, frameLoop, skipAnimation } from '@react-spring/shared/globals';\nimport { useMemoOne, useCallbackOne } from 'use-memo-one';\nimport { deprecateInterpolate } from '@react-spring/shared/deprecations';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport { createStringInterpolator as createStringInterpolator$1 } from '@react-spring/shared/stringInterpolation';\nexport * from '@react-spring/shared/types';\n\n/** API\n *  useChain(references, timeSteps, timeFrame)\n */\n\nfunction useChain(refs, timeSteps, timeFrame = 1000) {\n  useLayoutEffect(() => {\n    if (timeSteps) {\n      let prevDelay = 0;\n      each(refs, (ref, i) => {\n        if (!ref.current) return;\n        const {\n          controllers\n        } = ref.current;\n\n        if (controllers.length) {\n          let delay = timeFrame * timeSteps[i]; // Use the previous delay if none exists.\n\n          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;\n          each(controllers, ctrl => {\n            each(ctrl.queue, props => {\n              props.delay = delay + (props.delay || 0);\n            });\n            ctrl.start();\n          });\n        }\n      });\n    } else {\n      let p = Promise.resolve();\n      each(refs, ref => {\n        const {\n          controllers,\n          start\n        } = ref.current || {};\n\n        if (controllers && controllers.length) {\n          // Take the queue of each controller\n          const updates = controllers.map(ctrl => {\n            const q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          }); // Apply the queue when the previous ref stops animating\n\n          p = p.then(() => {\n            each(controllers, (ctrl, i) => ctrl.queue.push(...updates[i]));\n            return start();\n          });\n        }\n      });\n    }\n  });\n}\n\n// The `mass` prop defaults to 1\nconst config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\n\nconst linear = t => t;\n\nconst defaults = _extends(_extends({}, config.default), {}, {\n  mass: 1,\n  damping: 1,\n  easing: linear,\n  clamp: false\n});\n\nclass AnimationConfig {\n  /**\n   * With higher tension, the spring will resist bouncing and try harder to stop at its end value.\n   *\n   * When tension is zero, no animation occurs.\n   */\n\n  /**\n   * The damping ratio coefficient, or just the damping ratio when `speed` is defined.\n   *\n   * When `speed` is defined, this value should be between 0 and 1.\n   *\n   * Higher friction means the spring will slow down faster.\n   */\n\n  /**\n   * The natural frequency (in seconds), which dictates the number of bounces\n   * per second when no damping exists.\n   *\n   * When defined, `tension` is derived from this, and `friction` is derived\n   * from `tension` and `damping`.\n   */\n\n  /**\n   * The damping ratio, which dictates how the spring slows down.\n   *\n   * Set to `0` to never slow down. Set to `1` to slow down without bouncing.\n   * Between `0` and `1` is for you to explore.\n   *\n   * Only works when `frequency` is defined.\n   *\n   * Defaults to 1\n   */\n\n  /**\n   * Higher mass means more friction is required to slow down.\n   *\n   * Defaults to 1, which works fine most of the time.\n   */\n\n  /**\n   * The initial velocity of one or more values.\n   */\n\n  /**\n   * The smallest velocity before the animation is considered \"not moving\".\n   *\n   * When undefined, `precision` is used instead.\n   */\n\n  /**\n   * The smallest distance from a value before that distance is essentially zero.\n   *\n   * This helps in deciding when a spring is \"at rest\". The spring must be within\n   * this distance from its final value, and its velocity must be lower than this\n   * value too (unless `restVelocity` is defined).\n   */\n\n  /**\n   * For `duration` animations only. Note: The `duration` is not affected\n   * by this property.\n   *\n   * Defaults to `0`, which means \"start from the beginning\".\n   *\n   * Setting to `1+` makes an immediate animation.\n   *\n   * Setting to `0.5` means \"start from the middle of the easing function\".\n   *\n   * Any number `>= 0` and `<= 1` makes sense here.\n   */\n\n  /**\n   * Animation length in number of milliseconds.\n   */\n\n  /**\n   * The animation curve. Only used when `duration` is defined.\n   *\n   * Defaults to quadratic ease-in-out.\n   */\n\n  /**\n   * Avoid overshooting by ending abruptly at the goal value.\n   */\n\n  /**\n   * When above zero, the spring will bounce instead of overshooting when\n   * exceeding its goal value. Its velocity is multiplied by `-1 + bounce`\n   * whenever its current value equals or exceeds its goal. For example,\n   * setting `bounce` to `0.5` chops the velocity in half on each bounce,\n   * in addition to any friction.\n   */\n\n  /**\n   * \"Decay animations\" decelerate without an explicit goal value.\n   * Useful for scrolling animations.\n   *\n   * Use `true` for the default exponential decay factor (`0.998`).\n   *\n   * When a `number` between `0` and `1` is given, a lower number makes the\n   * animation slow down faster. And setting to `1` would make an unending\n   * animation.\n   */\n\n  /**\n   * While animating, round to the nearest multiple of this number.\n   * The `from` and `to` values are never rounded, as well as any value\n   * passed to the `set` method of an animated value.\n   */\n  constructor() {\n    this.tension = void 0;\n    this.friction = void 0;\n    this.frequency = void 0;\n    this.damping = void 0;\n    this.mass = void 0;\n    this.velocity = 0;\n    this.restVelocity = void 0;\n    this.precision = void 0;\n    this.progress = void 0;\n    this.duration = void 0;\n    this.easing = void 0;\n    this.clamp = void 0;\n    this.bounce = void 0;\n    this.decay = void 0;\n    this.round = void 0;\n    Object.assign(this, defaults);\n  }\n\n}\nfunction mergeConfig(config, newConfig, defaultConfig) {\n  if (defaultConfig) {\n    defaultConfig = _extends({}, defaultConfig);\n    sanitizeConfig(defaultConfig, newConfig);\n    newConfig = _extends(_extends({}, defaultConfig), newConfig);\n  }\n\n  sanitizeConfig(config, newConfig);\n  Object.assign(config, newConfig);\n\n  for (const key in defaults) {\n    if (config[key] == null) {\n      config[key] = defaults[key];\n    }\n  }\n\n  let {\n    mass,\n    frequency,\n    damping\n  } = config;\n\n  if (!is.und(frequency)) {\n    if (frequency < 0.01) frequency = 0.01;\n    if (damping < 0) damping = 0;\n    config.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;\n    config.friction = 4 * Math.PI * damping * mass / frequency;\n  }\n\n  return config;\n} // Prevent a config from accidentally overriding new props.\n// This depends on which \"config\" props take precedence when defined.\n\nfunction sanitizeConfig(config, props) {\n  if (!is.und(props.decay)) {\n    config.duration = undefined;\n  } else {\n    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);\n\n    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {\n      config.duration = undefined;\n      config.decay = undefined;\n    }\n\n    if (isTensionConfig) {\n      config.frequency = undefined;\n    }\n  }\n}\n\nconst emptyArray = [];\n/** @internal */\n\n/** An animation being executed by the frameloop */\nclass Animation {\n  constructor() {\n    this.changed = false;\n    this.values = emptyArray;\n    this.toValues = null;\n    this.fromValues = emptyArray;\n    this.to = void 0;\n    this.from = void 0;\n    this.config = new AnimationConfig();\n    this.immediate = false;\n    this.onStart = void 0;\n    this.onChange = void 0;\n    this.onRest = [];\n  }\n\n}\n\n// @see https://github.com/alexreardon/use-memo-one/pull/10\nconst useMemo = (create, deps) => useMemoOne(create, deps || [{}]);\nfunction callProp(value, ...args) {\n  return is.fun(value) ? value(...args) : value;\n}\n/** Try to coerce the given value into a boolean using the given key */\n\nconst matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));\nconst getProps = (props, i, arg) => props && (is.fun(props) ? props(i, arg) : is.arr(props) ? props[i] : _extends({}, props));\n/** Returns `true` if the given prop is having its default value set. */\n\nconst hasDefaultProp = (props, key) => !is.und(getDefaultProp(props, key));\n/** Get the default value being set for the given `key` */\n\nconst getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : undefined;\n/**\n * Extract the default props from an update.\n *\n * When the `default` prop is falsy, this function still behaves as if\n * `default: true` was used. The `default` prop is always respected when\n * truthy.\n */\n\nconst getDefaultProps = (props, omitKeys = [], defaults = {}) => {\n  let keys = DEFAULT_PROPS;\n\n  if (props.default && props.default !== true) {\n    props = props.default;\n    keys = Object.keys(props);\n  }\n\n  for (const key of keys) {\n    const value = props[key];\n\n    if (!is.und(value) && !omitKeys.includes(key)) {\n      defaults[key] = value;\n    }\n  }\n\n  return defaults;\n};\n/** Merge the default props of an update into a props cache. */\n\nconst mergeDefaultProps = (defaults, props, omitKeys) => getDefaultProps(props, omitKeys, defaults);\n/** These props can have default values */\n\nconst DEFAULT_PROPS = ['pause', 'cancel', 'config', 'immediate', 'onDelayEnd', 'onProps', 'onStart', 'onChange', 'onRest'];\nconst RESERVED_PROPS = {\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  loop: 1,\n  reset: 1,\n  pause: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  default: 1,\n  delay: 1,\n  onDelayEnd: 1,\n  onProps: 1,\n  onStart: 1,\n  onChange: 1,\n  onRest: 1,\n  // Transition props\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  update: 1,\n  leave: 1,\n  children: 1,\n  // Internal props\n  keys: 1,\n  callId: 1,\n  parentId: 1\n};\n/**\n * Extract any properties whose keys are *not* reserved for customizing your\n * animations. All hooks use this function, which means `useTransition` props\n * are reserved for `useSpring` calls, etc.\n */\n\nfunction getForwardProps(props) {\n  const forward = {};\n  let count = 0;\n  each(props, (value, prop) => {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value;\n      count++;\n    }\n  });\n\n  if (count) {\n    return forward;\n  }\n}\n/**\n * Clone the given `props` and move all non-reserved props\n * into the `to` prop.\n */\n\n\nfunction inferTo(props) {\n  const to = getForwardProps(props);\n\n  if (to) {\n    const out = {\n      to\n    };\n    each(props, (val, key) => key in to || (out[key] = val));\n    return out;\n  }\n\n  return _extends({}, props);\n} // Compute the goal value, converting \"red\" to \"rgba(255, 0, 0, 1)\" in the process\n\nfunction computeGoal(value) {\n  const config = getFluidConfig(value);\n  return config ? computeGoal(config.get()) : is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n}\n\n/**\n * This function sets a timeout if both the `delay` prop exists and\n * the `cancel` prop is not `true`.\n *\n * The `actions.start` function must handle the `cancel` prop itself,\n * but the `pause` prop is taken care of.\n */\nfunction scheduleProps(callId, {\n  key,\n  props,\n  state,\n  actions\n}) {\n  return new Promise((resolve, reject) => {\n    let delay;\n    let timeout;\n    let pause = false;\n    let cancel = matchProp(props.cancel, key);\n\n    if (cancel) {\n      onStart();\n    } else {\n      delay = callProp(props.delay || 0, key);\n      pause = matchProp(props.pause, key);\n\n      if (pause) {\n        state.resumeQueue.add(onResume);\n        actions.pause();\n      } else {\n        actions.resume();\n        onResume();\n      }\n    }\n\n    function onPause() {\n      state.resumeQueue.add(onResume);\n      timeout.cancel(); // Cache the remaining delay.\n\n      delay = timeout.time - Globals.now();\n    }\n\n    function onResume() {\n      if (delay > 0) {\n        state.pauseQueue.add(onPause);\n        timeout = Globals.frameLoop.setTimeout(onStart, delay);\n      } else {\n        onStart();\n      }\n    }\n\n    function onStart() {\n      state.pauseQueue.delete(onPause); // Maybe cancelled during its delay.\n\n      if (callId <= (state.cancelId || 0)) {\n        cancel = true;\n      }\n\n      try {\n        actions.start(_extends(_extends({}, props), {}, {\n          callId,\n          delay,\n          cancel,\n          pause\n        }), resolve);\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n}\n\n/** @internal */\n\n/** The object given to the `onRest` prop and `start` promise. */\n\n/** The promised result of an animation. */\n\n/** @internal */\nconst getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some(result => result.cancelled) ? getCancelledResult(target) : results.every(result => result.noop) ? getNoopResult(target) : getFinishedResult(target, results.every(result => result.finished));\n/** No-op results are for updates that never start an animation. */\n\nconst getNoopResult = (target, value = target.get()) => ({\n  value,\n  noop: true,\n  finished: true,\n  target\n});\nconst getFinishedResult = (target, finished, value = target.get()) => ({\n  value,\n  finished,\n  target\n});\nconst getCancelledResult = (target, value = target.get()) => ({\n  value,\n  cancelled: true,\n  target\n});\n\n/**\n * Start an async chain or an async script.\n *\n * Always call `runAsync` in the action callback of a `scheduleProps` call.\n *\n * The `T` parameter can be a set of animated values (as an object type)\n * or a primitive type for a single animated value.\n */\nasync function runAsync(to, props, state, target) {\n  if (props.pause) {\n    await new Promise(resume => {\n      state.resumeQueue.add(resume);\n    });\n  }\n\n  const {\n    callId,\n    parentId,\n    onRest\n  } = props;\n  const {\n    asyncTo: prevTo,\n    promise: prevPromise\n  } = state;\n\n  if (!parentId && to === prevTo && !props.reset) {\n    return prevPromise;\n  }\n\n  return state.promise = (async () => {\n    state.asyncId = callId;\n    state.asyncTo = to; // The default props of any `animate` calls.\n\n    const defaultProps = getDefaultProps(props, [// The `onRest` prop is only called when the `runAsync` promise is resolved.\n    'onRest']);\n    let preventBail;\n    let bail; // This promise is rejected when the animation is interrupted.\n\n    const bailPromise = new Promise((resolve, reject) => (preventBail = resolve, bail = reject)); // Stop animating when an error is caught.\n\n    const withBailHandler = fn => (...args) => {\n      const onError = err => {\n        if (err instanceof BailSignal) {\n          bail(err); // Stop animating.\n        }\n\n        throw err;\n      };\n\n      try {\n        return fn(...args).catch(onError);\n      } catch (err) {\n        onError(err);\n      }\n    };\n\n    const bailIfEnded = bailSignal => {\n      const bailResult = // The `cancel` prop or `stop` method was used.\n      callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.\n      callId !== state.asyncId && getFinishedResult(target, false);\n\n      if (bailResult) {\n        bailSignal.result = bailResult;\n        throw bailSignal;\n      }\n    }; // Note: This function cannot use the `async` keyword, because we want the\n    // `throw` statements to interrupt the caller.\n\n\n    const animate = withBailHandler((arg1, arg2) => {\n      const bailSignal = new BailSignal();\n      bailIfEnded(bailSignal);\n      const props = is.obj(arg1) ? _extends({}, arg1) : _extends(_extends({}, arg2), {}, {\n        to: arg1\n      });\n      props.parentId = callId;\n      each(defaultProps, (value, key) => {\n        if (is.und(props[key])) {\n          props[key] = value;\n        }\n      });\n      return target.start(props).then(async result => {\n        bailIfEnded(bailSignal);\n\n        if (target.is('PAUSED')) {\n          await new Promise(resume => {\n            state.resumeQueue.add(resume);\n          });\n        }\n\n        return result;\n      });\n    });\n    let result;\n\n    try {\n      let animating; // Async sequence\n\n      if (is.arr(to)) {\n        animating = (async queue => {\n          for (const props of queue) {\n            await animate(props);\n          }\n        })(to);\n      } // Async script\n      else if (is.fun(to)) {\n          animating = Promise.resolve(to(animate, target.stop.bind(target)));\n        }\n\n      await Promise.all([animating.then(preventBail), bailPromise]);\n      result = getFinishedResult(target, true); // Bail handling\n    } catch (err) {\n      if (err instanceof BailSignal) {\n        result = err.result;\n      } else {\n        throw err;\n      } // Reset the async state.\n\n    } finally {\n      if (callId == state.asyncId) {\n        state.asyncId = parentId;\n        state.asyncTo = parentId ? prevTo : undefined;\n        state.promise = parentId ? prevPromise : undefined;\n      }\n    }\n\n    if (is.fun(onRest)) {\n      batchedUpdates(() => {\n        onRest(result);\n      });\n    }\n\n    return result;\n  })();\n}\nfunction cancelAsync(state, callId) {\n  state.cancelId = callId;\n  state.asyncId = state.asyncTo = state.promise = undefined;\n}\n/** This error is thrown to signal an interrupted async animation. */\n\nclass BailSignal extends Error {\n  constructor() {\n    super('An async animation has been interrupted. You see this error because you ' + 'forgot to use `await` or `.catch(...)` on its returned promise.');\n    this.result = void 0;\n  }\n\n}\n\nconst isFrameValue = value => value instanceof FrameValue;\nlet nextId = 1;\n/**\n * A kind of `FluidValue` that manages an `AnimatedValue` node.\n *\n * Its underlying value can be accessed and even observed.\n */\n\nclass FrameValue extends FluidValue {\n  constructor(...args) {\n    super(...args);\n    this.id = nextId++;\n    this.key = void 0;\n    this._priority = 0;\n    this._children = new Set();\n  }\n\n  get priority() {\n    return this._priority;\n  }\n\n  set priority(priority) {\n    if (this._priority != priority) {\n      this._priority = priority;\n\n      this._onPriorityChange(priority);\n    }\n  }\n  /** Get the current value */\n\n\n  get() {\n    const node = getAnimated(this);\n    return node && node.getValue();\n  }\n  /** Create a spring that maps our value to another value */\n\n\n  to(...args) {\n    return to$1(this, args);\n  }\n  /** @deprecated Use the `to` method instead. */\n\n\n  interpolate(...args) {\n    deprecateInterpolate();\n    return to$1(this, args);\n  }\n  /** @internal */\n\n\n  /** @internal */\n  addChild(child) {\n    if (!this._children.size) this._attach();\n\n    this._children.add(child);\n  }\n  /** @internal */\n\n\n  removeChild(child) {\n    this._children.delete(child);\n\n    if (!this._children.size) this._detach();\n  }\n  /** @internal */\n\n\n  onParentChange({\n    type\n  }) {\n    if (this.idle) {\n      // Start animating when a parent does.\n      if (type == 'start') {\n        this._reset();\n\n        this._start();\n      }\n    } // Reset our animation state when a parent does, but only when\n    // our animation is active.\n    else if (type == 'reset') {\n        this._reset();\n      }\n  }\n  /** Called when the first child is added. */\n\n\n  _attach() {}\n  /** Called when the last child is removed. */\n\n\n  _detach() {}\n  /**\n   * Reset our animation state (eg: start values, velocity, etc)\n   * and tell our children to do the same.\n   *\n   * This is called when our goal value is changed during (or before)\n   * an animation.\n   */\n\n\n  _reset() {\n    this._emit({\n      type: 'reset',\n      parent: this\n    });\n  }\n  /**\n   * Start animating if possible.\n   *\n   * Note: Be sure to call `_reset` first, or the animation will break.\n   * This method would like to call `_reset` for you, but that would\n   * interfere with paused animations.\n   */\n\n\n  _start() {\n    this._emit({\n      type: 'start',\n      parent: this\n    });\n  }\n  /** Tell our children about our new value */\n\n\n  _onChange(value, idle = false) {\n    this._emit({\n      type: 'change',\n      parent: this,\n      value,\n      idle\n    });\n  }\n  /** Tell our children about our new priority */\n\n\n  _onPriorityChange(priority) {\n    if (!this.idle) {\n      // Make the frameloop aware of our new priority.\n      frameLoop.start(this);\n    }\n\n    this._emit({\n      type: 'priority',\n      parent: this,\n      priority\n    });\n  }\n\n  _emit(event) {\n    // Clone \"_children\" so it can be safely mutated inside the loop.\n    each(Array.from(this._children), child => {\n      child.onParentChange(event);\n    });\n  }\n\n}\n\n// TODO: use \"const enum\" when Babel supports it\n\n/** The spring has not animated yet */\nconst CREATED = 'CREATED';\n/** The spring has animated before */\n\nconst IDLE = 'IDLE';\n/** The spring is animating */\n\nconst ACTIVE = 'ACTIVE';\n/** The spring is frozen in time */\n\nconst PAUSED = 'PAUSED';\n/** The spring cannot be animated */\n\nconst DISPOSED = 'DISPOSED';\n\n/**\n * Only numbers, strings, and arrays of numbers/strings are supported.\n * Non-animatable strings are also supported.\n */\nclass SpringValue extends FrameValue {\n  /** The property name used when `to` or `from` is an object. Useful when debugging too. */\n\n  /** The animation state */\n\n  /** The queue of pending props */\n\n  /** The lifecycle phase of this spring */\n\n  /** The state for `runAsync` calls */\n\n  /** Some props have customizable default values */\n\n  /** The counter for tracking `scheduleProps` calls */\n\n  /** The last `scheduleProps` call that changed the `to` prop */\n  constructor(arg1, arg2) {\n    super();\n    this.key = void 0;\n    this.animation = new Animation();\n    this.queue = void 0;\n    this._phase = CREATED;\n    this._state = {\n      pauseQueue: new Set(),\n      resumeQueue: new Set()\n    };\n    this._defaultProps = {};\n    this._lastCallId = 0;\n    this._lastToId = 0;\n\n    if (!is.und(arg1) || !is.und(arg2)) {\n      const props = is.obj(arg1) ? _extends({}, arg1) : _extends(_extends({}, arg2), {}, {\n        from: arg1\n      });\n      props.default = true;\n      this.start(props);\n    }\n  }\n\n  get idle() {\n    return !this.is(ACTIVE) && !this._state.asyncTo;\n  }\n\n  get goal() {\n    return getFluidValue(this.animation.to);\n  }\n\n  get velocity() {\n    const node = getAnimated(this);\n    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map(node => node.lastVelocity || 0);\n  }\n  /** Advance the current animation by a number of milliseconds */\n\n\n  advance(dt) {\n    let idle = true;\n    let changed = false;\n    const anim = this.animation;\n    let {\n      config,\n      toValues\n    } = anim;\n    const payload = getPayload(anim.to);\n\n    if (!payload) {\n      const toConfig = getFluidConfig(anim.to);\n\n      if (toConfig) {\n        toValues = toArray(toConfig.get());\n      }\n    }\n\n    anim.values.forEach((node, i) => {\n      if (node.done) return; // The \"anim.toValues\" array must exist when no parent exists.\n\n      let to = payload ? payload[i].lastPosition : toValues[i];\n      let finished = anim.immediate;\n      let position = to;\n\n      if (!finished) {\n        position = node.lastPosition; // Loose springs never move.\n\n        if (config.tension <= 0) {\n          node.done = true;\n          return;\n        }\n\n        const elapsed = node.elapsedTime += dt;\n        const from = anim.fromValues[i];\n        const v0 = node.v0 != null ? node.v0 : node.v0 = is.arr(config.velocity) ? config.velocity[i] : config.velocity;\n        let velocity; // Duration easing\n\n        if (!is.und(config.duration)) {\n          let p = config.progress || 0;\n          if (config.duration <= 0) p = 1;else p += (1 - p) * Math.min(1, elapsed / config.duration);\n          position = from + config.easing(p) * (to - from);\n          velocity = (position - node.lastPosition) / dt;\n          finished = p == 1;\n        } // Decay easing\n        else if (config.decay) {\n            const decay = config.decay === true ? 0.998 : config.decay;\n            const e = Math.exp(-(1 - decay) * elapsed);\n            position = from + v0 / (1 - decay) * (1 - e);\n            finished = Math.abs(node.lastPosition - position) < 0.1; // derivative of position\n\n            velocity = v0 * e;\n          } // Spring easing\n          else {\n              velocity = node.lastVelocity == null ? v0 : node.lastVelocity;\n              /** The smallest distance from a value before being treated like said value. */\n\n              const precision = config.precision || (from == to ? 0.005 : Math.min(1, Math.abs(to - from) * 0.001));\n              /** The velocity at which movement is essentially none */\n\n              const restVelocity = config.restVelocity || precision / 10; // Bouncing is opt-in (not to be confused with overshooting)\n\n              const bounceFactor = config.clamp ? 0 : config.bounce;\n              const canBounce = !is.und(bounceFactor);\n              /** When `true`, the value is increasing over time */\n\n              const isGrowing = from == to ? node.v0 > 0 : from < to;\n              /** When `true`, the velocity is considered moving */\n\n              let isMoving;\n              /** When `true`, the velocity is being deflected or clamped */\n\n              let isBouncing = false;\n              const step = 1; // 1ms\n\n              const numSteps = Math.ceil(dt / step);\n\n              for (let n = 0; n < numSteps; ++n) {\n                isMoving = Math.abs(velocity) > restVelocity;\n\n                if (!isMoving) {\n                  finished = Math.abs(to - position) <= precision;\n\n                  if (finished) {\n                    break;\n                  }\n                }\n\n                if (canBounce) {\n                  isBouncing = position == to || position > to == isGrowing; // Invert the velocity with a magnitude, or clamp it.\n\n                  if (isBouncing) {\n                    velocity = -velocity * bounceFactor;\n                    position = to;\n                  }\n                }\n\n                const springForce = -config.tension * 0.000001 * (position - to);\n                const dampingForce = -config.friction * 0.001 * velocity;\n                const acceleration = (springForce + dampingForce) / config.mass; // pt/ms^2\n\n                velocity = velocity + acceleration * step; // pt/ms\n\n                position = position + velocity * step;\n              }\n            }\n\n        node.lastVelocity = velocity;\n\n        if (Number.isNaN(position)) {\n          console.warn(\"Got NaN while animating:\", this);\n          finished = true;\n        }\n      } // Parent springs must finish before their children can.\n\n\n      if (payload && !payload[i].done) {\n        finished = false;\n      }\n\n      if (finished) {\n        node.done = true;\n      } else {\n        idle = false;\n      }\n\n      if (node.setValue(position, config.round)) {\n        changed = true;\n      }\n    });\n\n    if (idle) {\n      this.finish();\n    } else if (changed) {\n      this._onChange(this.get());\n    }\n\n    return idle;\n  }\n  /** Check the current phase */\n\n\n  is(phase) {\n    return this._phase == phase;\n  }\n  /** Set the current value, while stopping the current animation */\n\n\n  set(value) {\n    batchedUpdates(() => {\n      this._focus(value);\n\n      if (this._set(value)) {\n        // Ensure change observers are notified. When active,\n        // the \"_stop\" method handles this.\n        if (!this.is(ACTIVE)) {\n          return this._onChange(this.get(), true);\n        }\n      }\n\n      this._stop();\n    });\n    return this;\n  }\n  /**\n   * Freeze the active animation in time.\n   * This does nothing when not animating.\n   */\n\n\n  pause() {\n    checkDisposed(this, 'pause');\n\n    if (!this.is(PAUSED)) {\n      this._phase = PAUSED;\n      flush(this._state.pauseQueue, onPause => onPause());\n    }\n  }\n  /** Resume the animation if paused. */\n\n\n  resume() {\n    checkDisposed(this, 'resume');\n\n    if (this.is(PAUSED)) {\n      this._start();\n\n      flush(this._state.resumeQueue, onResume => onResume());\n    }\n  }\n  /**\n   * Skip to the end of the current animation.\n   *\n   * All `onRest` callbacks are passed `{finished: true}`\n   */\n\n\n  finish(to) {\n    this.resume();\n\n    if (this.is(ACTIVE)) {\n      const anim = this.animation; // Decay animations have an implicit goal.\n\n      if (!anim.config.decay && is.und(to)) {\n        to = anim.to;\n      } // Set the value if we can.\n\n\n      if (!is.und(to)) {\n        this._set(to);\n      }\n\n      batchedUpdates(() => {\n        // Ensure the \"onStart\" and \"onRest\" props are called.\n        if (!anim.changed) {\n          anim.changed = true;\n\n          if (anim.onStart) {\n            anim.onStart(this);\n          }\n        } // Exit the frameloop.\n\n\n        this._stop();\n      });\n    }\n\n    return this;\n  }\n  /** Push props into the pending queue. */\n\n\n  update(props) {\n    checkDisposed(this, 'update');\n    const queue = this.queue || (this.queue = []);\n    queue.push(props);\n    return this;\n  }\n  /**\n   * Update this value's animation using the queue of pending props,\n   * and unpause the current animation (if one is frozen).\n   *\n   * When arguments are passed, a new animation is created, and the\n   * queued animations are left alone.\n   */\n\n\n  async start(to, arg2) {\n    checkDisposed(this, 'start');\n    let queue;\n\n    if (!is.und(to)) {\n      queue = [is.obj(to) ? to : _extends(_extends({}, arg2), {}, {\n        to\n      })];\n    } else {\n      queue = this.queue || [];\n      this.queue = [];\n    }\n\n    const results = await Promise.all(queue.map(props => this._update(props)));\n    return getCombinedResult(this, results);\n  }\n  /**\n   * Stop the current animation, and cancel any delayed updates.\n   *\n   * Pass `true` to call `onRest` with `cancelled: true`.\n   */\n\n\n  stop(cancel) {\n    if (!this.is(DISPOSED)) {\n      cancelAsync(this._state, this._lastCallId); // Ensure the `to` value equals the current value.\n\n      this._focus(this.get()); // Exit the frameloop and notify `onRest` listeners.\n\n\n      batchedUpdates(() => this._stop(cancel));\n    }\n\n    return this;\n  }\n  /** Restart the animation. */\n\n\n  reset() {\n    this._update({\n      reset: true\n    });\n  }\n  /** Prevent future animations, and stop the current animation */\n\n\n  dispose() {\n    if (!this.is(DISPOSED)) {\n      if (this.animation) {\n        // Prevent \"onRest\" calls when disposed.\n        this.animation.onRest = [];\n      }\n\n      this.stop();\n      this._phase = DISPOSED;\n    }\n  }\n  /** @internal */\n\n\n  onParentChange(event) {\n    super.onParentChange(event);\n\n    if (event.type == 'change') {\n      if (!this.is(ACTIVE)) {\n        this._reset();\n\n        if (!this.is(PAUSED)) {\n          this._start();\n        }\n      }\n    } else if (event.type == 'priority') {\n      this.priority = event.priority + 1;\n    }\n  }\n  /**\n   * Parse the `to` and `from` range from the given `props` object.\n   *\n   * This also ensures the initial value is available to animated components\n   * during the render phase.\n   */\n\n\n  _prepareNode({\n    to,\n    from,\n    reverse\n  }) {\n    const key = this.key || '';\n    to = !is.obj(to) || getFluidConfig(to) ? to : to[key];\n    from = !is.obj(from) || getFluidConfig(from) ? from : from[key]; // Create the range now to avoid \"reverse\" logic.\n\n    const range = {\n      to,\n      from\n    }; // Before ever animating, this method ensures an `Animated` node\n    // exists and keeps its value in sync with the \"from\" prop.\n\n    if (this.is(CREATED)) {\n      if (reverse) [to, from] = [from, to];\n      from = getFluidValue(from);\n\n      const node = this._updateNode(is.und(from) ? getFluidValue(to) : from);\n\n      if (node && !is.und(from)) {\n        node.setValue(from);\n      }\n    }\n\n    return range;\n  }\n  /**\n   * Create an `Animated` node if none exists or the given value has an\n   * incompatible type. Do nothing if `value` is undefined.\n   *\n   * The newest `Animated` node is returned.\n   */\n\n\n  _updateNode(value) {\n    let node = getAnimated(this);\n\n    if (!is.und(value)) {\n      const nodeType = this._getNodeType(value);\n\n      if (!node || node.constructor !== nodeType) {\n        setAnimated(this, node = nodeType.create(value));\n      }\n    }\n\n    return node;\n  }\n  /** Return the `Animated` node constructor for a given value */\n\n\n  _getNodeType(value) {\n    const parentNode = getAnimated(value);\n    return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  }\n  /** Schedule an animation to run after an optional delay */\n\n\n  _update(props, isLoop) {\n    const defaultProps = this._defaultProps;\n\n    const mergeDefaultProp = key => {\n      const value = getDefaultProp(props, key);\n\n      if (!is.und(value)) {\n        defaultProps[key] = value;\n      } // For `cancel` and `pause`, a truthy default always wins.\n\n\n      if (defaultProps[key]) {\n        props[key] = defaultProps[key];\n      }\n    }; // These props are coerced into booleans by the `scheduleProps` function,\n    // so they need their default values processed before then.\n\n\n    mergeDefaultProp('cancel');\n    mergeDefaultProp('pause'); // Ensure the initial value can be accessed by animated components.\n\n    const range = this._prepareNode(props);\n\n    return scheduleProps(++this._lastCallId, {\n      key: this.key,\n      props,\n      state: this._state,\n      actions: {\n        pause: this.pause.bind(this),\n        resume: this.resume.bind(this),\n        start: this._merge.bind(this, range)\n      }\n    }).then(result => {\n      if (props.loop && result.finished && !(isLoop && result.noop)) {\n        const nextProps = createLoopUpdate(props);\n\n        if (nextProps) {\n          return this._update(nextProps, true);\n        }\n      }\n\n      return result;\n    });\n  }\n  /** Merge props into the current animation */\n\n\n  _merge(range, props, resolve) {\n    // The \"cancel\" prop cancels all pending delays and it forces the\n    // active animation to stop where it is.\n    if (props.cancel) {\n      this.stop(true);\n      return resolve(getCancelledResult(this));\n    }\n\n    const {\n      key,\n      animation: anim\n    } = this;\n    const defaultProps = this._defaultProps;\n    /** The \"to\" prop is defined. */\n\n    const hasToProp = !is.und(range.to);\n    /** The \"from\" prop is defined. */\n\n    const hasFromProp = !is.und(range.from); // Avoid merging other props if implicitly prevented, except\n    // when both the \"to\" and \"from\" props are undefined.\n\n    if (hasToProp || hasFromProp) {\n      if (props.callId > this._lastToId) {\n        this._lastToId = props.callId;\n      } else {\n        return resolve(getCancelledResult(this));\n      }\n    }\n    /** Get the value of a prop, or its default value */\n\n\n    const get = prop => !is.und(props[prop]) ? props[prop] : defaultProps[prop]; // Call \"onDelayEnd\" before merging props, but after cancellation checks.\n\n\n    const onDelayEnd = coerceEventProp(get('onDelayEnd'), key);\n\n    if (onDelayEnd) {\n      onDelayEnd(props, this);\n    }\n\n    if (props.default) {\n      mergeDefaultProps(defaultProps, props, ['pause', 'cancel']);\n    }\n\n    const {\n      to: prevTo,\n      from: prevFrom\n    } = anim;\n    let {\n      to = prevTo,\n      from = prevFrom\n    } = range; // Focus the \"from\" value if changing without a \"to\" value.\n\n    if (hasFromProp && !hasToProp) {\n      to = from;\n    } // Flip the current range if \"reverse\" is true.\n\n\n    if (props.reverse) [to, from] = [from, to];\n    /** The \"from\" value is changing. */\n\n    const hasFromChanged = !isEqual(from, prevFrom);\n\n    if (hasFromChanged) {\n      anim.from = from;\n    }\n    /** The \"to\" value is changing. */\n\n\n    const hasToChanged = !isEqual(to, prevTo);\n\n    if (hasToChanged) {\n      this._focus(to);\n    } // Both \"from\" and \"to\" can use a fluid config (thanks to http://npmjs.org/fluids).\n\n\n    const toConfig = getFluidConfig(to);\n    const fromConfig = getFluidConfig(from);\n\n    if (fromConfig) {\n      from = fromConfig.get();\n    }\n    /** The \"to\" prop is async. */\n\n\n    const hasAsyncTo = is.arr(props.to) || is.fun(props.to);\n    const {\n      config\n    } = anim;\n    const {\n      decay,\n      velocity\n    } = config; // The \"runAsync\" function treats the \"config\" prop as a default,\n    // so we must avoid merging it when the \"to\" prop is async.\n\n    if (props.config && !hasAsyncTo) {\n      mergeConfig(config, callProp(props.config, key), // Avoid calling the same \"config\" prop twice.\n      props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0);\n    } // This instance might not have its Animated node yet. For example,\n    // the constructor can be given props without a \"to\" or \"from\" value.\n\n\n    let node = getAnimated(this);\n\n    if (!node || is.und(to)) {\n      return resolve(getFinishedResult(this, true));\n    }\n    /** When true, start at the \"from\" value. */\n\n\n    const reset = // When `reset` is undefined, the `from` prop implies `reset: true`,\n    // except for declarative updates. When `reset` is defined, there\n    // must exist a value to animate from.\n    is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key); // The current value, where the animation starts from.\n\n    const value = reset ? from : this.get(); // The animation ends at this value, unless \"to\" is fluid.\n\n    const goal = computeGoal(to); // Only specific types can be animated to/from.\n\n    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal); // When true, the value changes instantly on the next frame.\n\n    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));\n\n    if (hasToChanged) {\n      if (immediate) {\n        node = this._updateNode(goal);\n      } else {\n        const nodeType = this._getNodeType(to);\n\n        if (nodeType !== node.constructor) {\n          throw Error(\"Cannot animate between \" + node.constructor.name + \" and \" + nodeType.name + \", as the \\\"to\\\" prop suggests\");\n        }\n      }\n    } // The type of Animated node for the goal value.\n\n\n    const goalType = node.constructor; // When the goal value is fluid, we don't know if its value\n    // will change before the next animation frame, so it always\n    // starts the animation to be safe.\n\n    let started = !!toConfig;\n    let finished = false;\n\n    if (!started) {\n      // When true, the current value has probably changed.\n      const hasValueChanged = reset || this.is(CREATED) && hasFromChanged; // When the \"to\" value or current value are changed,\n      // start animating if not already finished.\n\n      if (hasToChanged || hasValueChanged) {\n        finished = isEqual(computeGoal(value), goal);\n        started = !finished;\n      } // Changing \"decay\" or \"velocity\" starts the animation.\n\n\n      if (!isEqual(config.decay, decay) || !isEqual(config.velocity, velocity)) {\n        started = true;\n      }\n    } // When an active animation changes its goal to its current value:\n\n\n    if (finished && this.is(ACTIVE)) {\n      // Avoid an abrupt stop unless the animation is being reset.\n      if (anim.changed && !reset) {\n        started = true;\n      } // Stop the animation before its first frame.\n      else if (!started) {\n          this._stop();\n        }\n    }\n\n    if (!hasAsyncTo) {\n      // Make sure our \"toValues\" are updated even if our previous\n      // \"to\" prop is a fluid value whose current value is also ours.\n      if (started || getFluidConfig(prevTo)) {\n        anim.values = node.getPayload();\n        anim.toValues = toConfig ? null : goalType == AnimatedString ? [1] : toArray(goal);\n      }\n\n      anim.immediate = immediate;\n      anim.onStart = coerceEventProp(get('onStart'), key);\n      anim.onChange = coerceEventProp(get('onChange'), key); // The \"reset\" prop tries to reuse the old \"onRest\" prop,\n      // unless you defined a new \"onRest\" prop.\n\n      const onRestQueue = anim.onRest;\n      const onRest = reset && !props.onRest ? onRestQueue[0] || noop : checkFinishedOnRest(coerceEventProp(get('onRest'), key), this); // In most cases, the animation after this one won't reuse our\n      // \"onRest\" prop. Instead, the _default_ \"onRest\" prop is used\n      // when the next animation has an undefined \"onRest\" prop.\n\n      if (started) {\n        anim.onRest = [onRest, checkFinishedOnRest(resolve, this)]; // Flush the \"onRest\" queue for the previous animation.\n\n        let onRestIndex = reset ? 0 : 1;\n\n        if (onRestIndex < onRestQueue.length) {\n          batchedUpdates(() => {\n            for (; onRestIndex < onRestQueue.length; onRestIndex++) {\n              onRestQueue[onRestIndex]();\n            }\n          });\n        }\n      } // The \"onRest\" prop is always first, and it can be updated even\n      // if a new animation is not started by this update.\n      else if (reset || props.onRest) {\n          anim.onRest[0] = onRest;\n        }\n    } // By this point, every prop has been merged.\n\n\n    const onProps = coerceEventProp(get('onProps'), key);\n\n    if (onProps) {\n      onProps(props, this);\n    } // Update our node even if the animation is idle.\n\n\n    if (reset) {\n      node.setValue(value);\n    }\n\n    if (hasAsyncTo) {\n      resolve(runAsync(props.to, props, this._state, this));\n    } // Start an animation\n    else if (started) {\n        // Must be idle for \"onStart\" to be called again.\n        if (reset) this._phase = IDLE;\n\n        this._reset();\n\n        this._start();\n      } // Postpone promise resolution until the animation is finished,\n      // so that no-op updates still resolve at the expected time.\n      else if (this.is(ACTIVE) && !hasToChanged) {\n          anim.onRest.push(checkFinishedOnRest(resolve, this));\n        } // Resolve our promise immediately.\n        else {\n            resolve(getNoopResult(this, value));\n          }\n  }\n  /** Update the `animation.to` value, which might be a `FluidValue` */\n\n\n  _focus(value) {\n    const anim = this.animation;\n\n    if (value !== anim.to) {\n      let config = getFluidConfig(anim.to);\n\n      if (config) {\n        config.removeChild(this);\n      }\n\n      anim.to = value;\n      let priority = 0;\n\n      if (config = getFluidConfig(value)) {\n        config.addChild(this);\n\n        if (isFrameValue(value)) {\n          priority = (value.priority || 0) + 1;\n        }\n      }\n\n      this.priority = priority;\n    }\n  }\n  /** Set the current value and our `node` if necessary. The `_onChange` method is *not* called. */\n\n\n  _set(value) {\n    const config = getFluidConfig(value);\n\n    if (config) {\n      value = config.get();\n    }\n\n    const node = getAnimated(this);\n    const oldValue = node && node.getValue();\n\n    if (node) {\n      node.setValue(value);\n    } else {\n      this._updateNode(value);\n    }\n\n    return !isEqual(value, oldValue);\n  }\n\n  _onChange(value, idle = false) {\n    const anim = this.animation; // The \"onStart\" prop is called on the first change after entering the\n    // frameloop, but never for immediate animations.\n\n    if (!anim.changed && !idle) {\n      anim.changed = true;\n\n      if (anim.onStart) {\n        anim.onStart(this);\n      }\n    }\n\n    if (anim.onChange) {\n      anim.onChange(value, this);\n    }\n\n    super._onChange(value, idle);\n  }\n\n  _reset() {\n    const anim = this.animation; // Reset the state of each Animated node.\n\n    getAnimated(this).reset(anim.to); // Ensure the `onStart` prop will be called.\n\n    if (!this.is(ACTIVE)) {\n      anim.changed = false;\n    } // Use the current values as the from values.\n\n\n    if (!anim.immediate) {\n      anim.fromValues = anim.values.map(node => node.lastPosition);\n    }\n\n    super._reset();\n  }\n\n  _start() {\n    if (!this.is(ACTIVE)) {\n      this._phase = ACTIVE;\n\n      super._start(); // The \"skipAnimation\" global avoids the frameloop.\n\n\n      if (skipAnimation) {\n        this.finish();\n      } else {\n        frameLoop.start(this);\n      }\n    }\n  }\n  /**\n   * Exit the frameloop and notify `onRest` listeners.\n   *\n   * Always wrap `_stop` calls with `batchedUpdates`.\n   */\n\n\n  _stop(cancel) {\n    this.resume();\n\n    if (this.is(ACTIVE)) {\n      this._phase = IDLE; // Always let change observers know when a spring becomes idle.\n\n      this._onChange(this.get(), true);\n\n      const anim = this.animation;\n      each(anim.values, node => {\n        node.done = true;\n      });\n      const onRestQueue = anim.onRest;\n\n      if (onRestQueue.length) {\n        // Preserve the \"onRest\" prop when the goal is dynamic.\n        anim.onRest = [anim.toValues ? noop : onRestQueue[0]]; // Never call the \"onRest\" prop for no-op animations.\n\n        if (!anim.changed) {\n          onRestQueue[0] = noop;\n        }\n\n        each(onRestQueue, onRest => onRest(cancel));\n      }\n    }\n  }\n\n}\n\nfunction checkDisposed(spring, name) {\n  if (spring.is(DISPOSED)) {\n    throw Error(\"Cannot call \\\"\" + name + \"\\\" of disposed \\\"\" + spring.constructor.name + \"\\\" object\");\n  }\n}\n/** Coerce an event prop to an event handler */\n\n\nfunction coerceEventProp(prop, key) {\n  return is.fun(prop) ? prop : key && prop ? prop[key] : undefined;\n}\n/**\n * The \"finished\" value is determined by each \"onRest\" handler,\n * based on whether the current value equals the goal value that\n * was calculated at the time the \"onRest\" handler was set.\n */\n\n\nconst checkFinishedOnRest = (onRest, spring) => {\n  const {\n    to\n  } = spring.animation;\n  return onRest ? cancel => {\n    if (cancel) {\n      onRest(getCancelledResult(spring));\n    } else {\n      const goal = computeGoal(to);\n      const value = computeGoal(spring.get());\n      const finished = isEqual(value, goal);\n      onRest(getFinishedResult(spring, finished));\n    }\n  } : noop;\n};\n\nfunction createLoopUpdate(props, loop = props.loop, to = props.to) {\n  let loopRet = callProp(loop);\n\n  if (loopRet) {\n    const overrides = loopRet !== true && inferTo(loopRet);\n    const reverse = (overrides || props).reverse;\n    const reset = !overrides || overrides.reset;\n    return createUpdate(_extends(_extends({}, props), {}, {\n      loop,\n      // Avoid updating default props when looping.\n      default: false,\n      // For the \"reverse\" prop to loop as expected, the \"to\" prop\n      // must be undefined. The \"reverse\" prop is ignored when the\n      // \"to\" prop is an array or function.\n      to: !reverse || is.arr(to) || is.fun(to) ? to : undefined,\n      // Avoid defining the \"from\" prop if a reset is unwanted.\n      from: reset ? props.from : undefined,\n      reset\n    }, overrides));\n  }\n}\n/**\n * Return a new object based on the given `props`.\n *\n * - All unreserved props are moved into the `to` prop object.\n * - The `to` and `from` props are deleted when falsy.\n * - The `keys` prop is set to an array of affected keys,\n *   or `null` if all keys are affected.\n */\n\nfunction createUpdate(props) {\n  const {\n    to,\n    from\n  } = props = inferTo(props); // Collect the keys affected by this update.\n\n  const keys = new Set();\n\n  if (from) {\n    findDefined(from, keys);\n  } else {\n    // Falsy values are deleted to avoid merging issues.\n    delete props.from;\n  }\n\n  if (is.obj(to)) {\n    findDefined(to, keys);\n  } else if (!to) {\n    // Falsy values are deleted to avoid merging issues.\n    delete props.to;\n  } // The \"keys\" prop helps in applying updates to affected keys only.\n\n\n  props.keys = keys.size ? Array.from(keys) : null;\n  return props;\n}\n/**\n * A modified version of `createUpdate` meant for declarative APIs.\n */\n\nfunction declareUpdate(props) {\n  const update = createUpdate(props);\n\n  if (is.und(update.default)) {\n    update.default = getDefaultProps(update, [// Avoid forcing `immediate: true` onto imperative updates.\n    update.immediate === true && 'immediate']);\n  }\n\n  return update;\n}\n/** Find keys with defined values */\n\nfunction findDefined(values, keys) {\n  each(values, (value, key) => value != null && keys.add(key));\n}\n\n/** Events batched by the `Controller` class */\nconst BATCHED_EVENTS = ['onStart', 'onChange', 'onRest'];\nlet nextId$1 = 1;\n/** Queue of pending updates for a `Controller` instance. */\n\nclass Controller {\n  /** The animated values */\n\n  /** The queue of props passed to the `update` method. */\n\n  /** Custom handler for flushing update queues */\n\n  /** These props are used by all future spring values */\n\n  /** The combined phase of our spring values */\n\n  /** The counter for tracking `scheduleProps` calls */\n\n  /** The values currently being animated */\n\n  /** State used by the `runAsync` function */\n\n  /** The event queues that are flushed once per frame maximum */\n  constructor(props, flush) {\n    this.id = nextId$1++;\n    this.springs = {};\n    this.queue = [];\n    this._flush = void 0;\n    this._initialProps = void 0;\n    this._phase = CREATED;\n    this._lastAsyncId = 0;\n    this._active = new Set();\n    this._state = {\n      pauseQueue: new Set(),\n      resumeQueue: new Set()\n    };\n    this._events = {\n      onStart: new Set(),\n      onChange: new Set(),\n      onRest: new Map()\n    };\n    this._onFrame = this._onFrame.bind(this);\n\n    if (flush) {\n      this._flush = flush;\n    }\n\n    if (props) {\n      this.start(props);\n    }\n  }\n  /**\n   * Equals `true` when no spring values are in the frameloop, and\n   * no async animation is currently active.\n   */\n\n\n  get idle() {\n    return !this._state.asyncTo && Object.values(this.springs).every(spring => spring.idle);\n  }\n  /** Check the current phase */\n\n\n  is(phase) {\n    return this._phase == phase;\n  }\n  /** Get the current values of our springs */\n\n\n  get() {\n    const values = {};\n    this.each((spring, key) => values[key] = spring.get());\n    return values;\n  }\n  /** Push an update onto the queue of each value. */\n\n\n  update(props) {\n    if (props) this.queue.push(createUpdate(props));\n    return this;\n  }\n  /**\n   * Start the queued animations for every spring, and resolve the returned\n   * promise once all queued animations have finished or been cancelled.\n   *\n   * When you pass a queue (instead of nothing), that queue is used instead of\n   * the queued animations added with the `update` method, which are left alone.\n   */\n\n\n  start(props) {\n    const queue = props ? toArray(props).map(createUpdate) : this.queue;\n\n    if (!props) {\n      this.queue = [];\n    }\n\n    if (this._flush) {\n      return this._flush(this, queue);\n    }\n\n    prepareKeys(this, queue);\n    return flushUpdateQueue(this, queue);\n  }\n  /** Stop one animation, some animations, or all animations */\n\n\n  stop(keys) {\n    if (is.und(keys)) {\n      this.each(spring => spring.stop());\n      cancelAsync(this._state, this._lastAsyncId);\n    } else {\n      const springs = this.springs;\n      each(toArray(keys), key => springs[key].stop());\n    }\n\n    return this;\n  }\n  /** Freeze the active animation in time */\n\n\n  pause(keys) {\n    if (is.und(keys)) {\n      this.each(spring => spring.pause());\n    } else {\n      const springs = this.springs;\n      each(toArray(keys), key => springs[key].pause());\n    }\n\n    return this;\n  }\n  /** Resume the animation if paused. */\n\n\n  resume(keys) {\n    if (is.und(keys)) {\n      this.each(spring => spring.resume());\n    } else {\n      const springs = this.springs;\n      each(toArray(keys), key => springs[key].resume());\n    }\n\n    return this;\n  }\n  /** Restart every animation. */\n\n\n  reset() {\n    this.each(spring => spring.reset()); // TODO: restart async \"to\" prop\n\n    return this;\n  }\n  /** Call a function once per spring value */\n\n\n  each(iterator) {\n    each(this.springs, iterator);\n  }\n  /** Destroy every spring in this controller */\n\n\n  dispose() {\n    this._state.asyncTo = undefined;\n    this.each(spring => spring.dispose());\n    this.springs = {};\n  }\n  /** @internal Called at the end of every animation frame */\n\n\n  _onFrame() {\n    const {\n      onStart,\n      onChange,\n      onRest\n    } = this._events;\n    const isActive = this._active.size > 0;\n\n    if (isActive && this._phase != ACTIVE) {\n      this._phase = ACTIVE;\n      flush(onStart, onStart => onStart(this));\n    }\n\n    const values = (onChange.size || !isActive && onRest.size) && this.get();\n    flush(onChange, onChange => onChange(values)); // The \"onRest\" queue is only flushed when all springs are idle.\n\n    if (!isActive) {\n      this._phase = IDLE;\n      flush(onRest, ([onRest, result]) => {\n        result.value = values;\n        onRest(result);\n      });\n    }\n  }\n  /** @internal */\n\n\n  onParentChange(event) {\n    if (event.type == 'change') {\n      this._active[event.idle ? 'delete' : 'add'](event.parent);\n\n      frameLoop.onFrame(this._onFrame);\n    }\n  }\n\n}\n/**\n * Warning: Props might be mutated.\n */\n\nfunction flushUpdateQueue(ctrl, queue) {\n  return Promise.all(queue.map(props => flushUpdate(ctrl, props))).then(results => getCombinedResult(ctrl, results));\n}\n/**\n * Warning: Props might be mutated.\n *\n * Process a single set of props using the given controller.\n *\n * The returned promise resolves to `true` once the update is\n * applied and any animations it starts are finished without being\n * stopped or cancelled.\n */\n\nfunction flushUpdate(ctrl, props, isLoop) {\n  const {\n    to,\n    loop,\n    onRest\n  } = props; // Looping must be handled in this function, or else the values\n  // would end up looping out-of-sync in many common cases.\n\n  if (loop) {\n    props.loop = false;\n  }\n\n  const asyncTo = is.arr(to) || is.fun(to) ? to : undefined;\n\n  if (asyncTo) {\n    props.to = undefined;\n    props.onRest = undefined;\n  } else {\n    // For certain events, use batching to prevent multiple calls per frame.\n    // However, batching is avoided when the `to` prop is async, because any\n    // event props are used as default props instead.\n    each(BATCHED_EVENTS, key => {\n      const handler = props[key];\n\n      if (is.fun(handler)) {\n        const queue = ctrl['_events'][key];\n\n        if (queue instanceof Set) {\n          props[key] = () => queue.add(handler);\n        } else {\n          props[key] = ({\n            finished,\n            cancelled\n          }) => {\n            const result = queue.get(handler);\n\n            if (result) {\n              if (!finished) result.finished = false;\n              if (cancelled) result.cancelled = true;\n            } else {\n              // The \"value\" is set before the \"handler\" is called.\n              queue.set(handler, {\n                value: null,\n                finished,\n                cancelled\n              });\n            }\n          };\n        }\n      }\n    });\n  }\n\n  const keys = props.keys || Object.keys(ctrl.springs);\n  const promises = keys.map(key => ctrl.springs[key].start(props)); // Schedule the \"asyncTo\" if defined.\n\n  const state = ctrl['_state'];\n\n  if (asyncTo) {\n    promises.push(scheduleProps(++ctrl['_lastAsyncId'], {\n      props,\n      state,\n      actions: {\n        pause: noop,\n        resume: noop,\n\n        start(props, resolve) {\n          props.onRest = onRest;\n\n          if (!props.cancel) {\n            resolve(runAsync(asyncTo, props, state, ctrl));\n          } // Prevent `cancel: true` from ending the current `runAsync` call,\n          // except when the default `cancel` prop is being set.\n          else if (hasDefaultProp(props, 'cancel')) {\n              cancelAsync(state, props.callId);\n            }\n        }\n\n      }\n    }));\n  } // Respect the `cancel` prop when no keys are affected.\n  else if (!props.keys && props.cancel === true) {\n      cancelAsync(state, ctrl['_lastAsyncId']);\n    }\n\n  return Promise.all(promises).then(results => {\n    const result = getCombinedResult(ctrl, results);\n\n    if (loop && result.finished && !(isLoop && result.noop)) {\n      const nextProps = createLoopUpdate(props, loop, to);\n\n      if (nextProps) {\n        prepareKeys(ctrl, [nextProps]);\n        return flushUpdate(ctrl, nextProps, true);\n      }\n    }\n\n    return result;\n  });\n}\n/**\n * From an array of updates, get the map of `SpringValue` objects\n * by their keys. Springs are created when any update wants to\n * animate a new key.\n *\n * Springs created by `getSprings` are neither cached nor observed\n * until they're given to `setSprings`.\n */\n\nfunction getSprings(ctrl, props) {\n  const springs = _extends({}, ctrl.springs);\n\n  if (props) {\n    each(toArray(props), props => {\n      if (is.und(props.keys)) {\n        props = createUpdate(props);\n      }\n\n      if (!is.obj(props.to)) {\n        // Avoid passing array/function to each spring.\n        props = _extends(_extends({}, props), {}, {\n          to: undefined\n        });\n      }\n\n      prepareSprings(springs, props, key => {\n        return createSpring(key);\n      });\n    });\n  }\n\n  return springs;\n}\n/**\n * Tell a controller to manage the given `SpringValue` objects\n * whose key is not already in use.\n */\n\nfunction setSprings(ctrl, springs) {\n  each(springs, (spring, key) => {\n    if (!ctrl.springs[key]) {\n      ctrl.springs[key] = spring;\n      spring.addChild(ctrl);\n    }\n  });\n}\n\nfunction createSpring(key, observer) {\n  const spring = new SpringValue();\n  spring.key = key;\n\n  if (observer) {\n    spring.addChild(observer);\n  }\n\n  return spring;\n}\n/**\n * Ensure spring objects exist for each defined key.\n *\n * Using the `props`, the `Animated` node of each `SpringValue` may\n * be created or updated.\n */\n\n\nfunction prepareSprings(springs, props, create) {\n  if (props.keys) {\n    each(props.keys, key => {\n      const spring = springs[key] || (springs[key] = create(key));\n      spring['_prepareNode'](props);\n    });\n  }\n}\n/**\n * Ensure spring objects exist for each defined key, and attach the\n * `ctrl` to them for observation.\n *\n * The queue is expected to contain `createUpdate` results.\n */\n\n\nfunction prepareKeys(ctrl, queue) {\n  each(queue, props => {\n    prepareSprings(ctrl.springs, props, key => {\n      return createSpring(key, ctrl);\n    });\n  });\n}\n\n/**\n * This context affects all new and existing `SpringValue` objects\n * created with the hook API or the renderprops API.\n */\n\nconst ctx = createContext({});\nconst SpringContext = (_ref) => {\n  let {\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  const inherited = useContext(ctx); // Memoize the context to avoid unwanted renders.\n\n  props = useMemo(() => _extends(_extends({}, inherited), props), [inherited, props.pause, props.cancel, props.immediate, props.config]);\n  const {\n    Provider\n  } = ctx;\n  return /*#__PURE__*/createElement(Provider, {\n    value: props\n  }, children);\n};\nSpringContext.Provider = ctx.Provider;\nSpringContext.Consumer = ctx.Consumer;\n/** Get the current values of nearest `SpringContext` component. */\n\nconst useSpringContext = () => useContext(ctx);\n\n/** Create an imperative API for manipulating an array of `Controller` objects. */\nconst SpringHandle = {\n  create: getControllers => ({\n    get controllers() {\n      return getControllers();\n    },\n\n    update(props) {\n      each(getControllers(), (ctrl, i) => {\n        ctrl.update(getProps(props, i, ctrl));\n      });\n      return this;\n    },\n\n    async start(props) {\n      const results = await Promise.all(getControllers().map((ctrl, i) => {\n        const update = getProps(props, i, ctrl);\n        return ctrl.start(update);\n      }));\n      return {\n        value: results.map(result => result.value),\n        finished: results.every(result => result.finished)\n      };\n    },\n\n    stop: keys => each(getControllers(), ctrl => ctrl.stop(keys)),\n    pause: keys => each(getControllers(), ctrl => ctrl.pause(keys)),\n    resume: keys => each(getControllers(), ctrl => ctrl.resume(keys))\n  })\n};\n\n/** @internal */\nfunction useSprings(length, props, deps) {\n  const propsFn = is.fun(props) && props;\n  if (propsFn && !deps) deps = [];\n  // Set to 0 to prevent sync flush.\n  const layoutId = useRef(0);\n  const forceUpdate = useForceUpdate(); // State is updated on commit.\n\n  const [state] = useState(() => ({\n    ctrls: [],\n    queue: [],\n\n    flush(ctrl, updates) {\n      const springs = getSprings(ctrl, updates); // Flushing is postponed until the component's commit phase\n      // if a spring was created since the last commit.\n\n      const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs).some(key => !ctrl.springs[key]);\n      return canFlushSync ? flushUpdateQueue(ctrl, updates) : new Promise(resolve => {\n        setSprings(ctrl, springs);\n        state.queue.push(() => {\n          resolve(flushUpdateQueue(ctrl, updates));\n        });\n        forceUpdate();\n      });\n    }\n\n  })); // The imperative API ref from the props of the first controller.\n\n  const refProp = useRef();\n  const ctrls = [...state.ctrls];\n  const updates = []; // Cache old controllers to dispose in the commit phase.\n\n  const prevLength = usePrev(length) || 0;\n  const disposed = ctrls.slice(length, prevLength); // Create new controllers when \"length\" increases, and destroy\n  // the affected controllers when \"length\" decreases.\n\n  useMemo(() => {\n    ctrls.length = length;\n    declareUpdates(prevLength, length);\n  }, [length]); // Update existing controllers when \"deps\" are changed.\n\n  useMemo(() => {\n    declareUpdates(0, Math.min(prevLength, length));\n  }, deps);\n  /** Fill the `updates` array with declarative updates for the given index range. */\n\n  function declareUpdates(startIndex, endIndex) {\n    for (let i = startIndex; i < endIndex; i++) {\n      const ctrl = ctrls[i] || (ctrls[i] = new Controller(null, state.flush));\n      let update = propsFn ? propsFn(i, ctrl) : props[i];\n\n      if (update) {\n        update = updates[i] = declareUpdate(update);\n\n        if (i == 0) {\n          refProp.current = update.ref;\n          update.ref = undefined;\n        }\n      }\n    }\n  }\n\n  const api = useMemo$1(() => {\n    return SpringHandle.create(() => state.ctrls);\n  }, []); // New springs are created during render so users can pass them to\n  // their animated components, but new springs aren't cached until the\n  // commit phase (see the `useLayoutEffect` callback below).\n\n  const springs = ctrls.map((ctrl, i) => getSprings(ctrl, updates[i]));\n  const context = useSpringContext();\n  useLayoutEffect(() => {\n    layoutId.current++; // Replace the cached controllers.\n\n    state.ctrls = ctrls; // Update the ref prop.\n\n    if (refProp.current) {\n      refProp.current.current = api;\n    } // Flush the commit queue.\n\n\n    const {\n      queue\n    } = state;\n\n    if (queue.length) {\n      state.queue = [];\n      each(queue, cb => cb());\n    } // Dispose unused controllers.\n\n\n    each(disposed, ctrl => ctrl.dispose()); // Update existing controllers.\n\n    each(ctrls, (ctrl, i) => {\n      const values = springs[i];\n      setSprings(ctrl, values); // Update the default props.\n\n      ctrl.start({\n        default: context\n      }); // Apply updates created during render.\n\n      const update = updates[i];\n\n      if (update) {\n        // Start animating unless a ref exists.\n        if (refProp.current) {\n          ctrl.queue.push(update);\n        } else {\n          ctrl.start(update);\n        }\n      }\n    });\n  }); // Dispose all controllers on unmount.\n\n  useOnce(() => () => {\n    each(state.ctrls, ctrl => ctrl.dispose());\n  }); // Return a deep copy of the `springs` array so the caller can\n  // safely mutate it during render.\n\n  const values = springs.map(x => _extends({}, x));\n  return propsFn || arguments.length == 3 ? [values, api.start, api.stop] : values;\n}\n\n/**\n * The props that `useSpring` recognizes.\n */\n\n/** @internal */\nfunction useSpring(props, deps) {\n  const isFn = is.fun(props);\n  const [[values], update, stop] = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps);\n  return isFn || arguments.length == 2 ? [values, update, stop] : values;\n}\n\nfunction useTrail(length, propsArg, deps) {\n  const propsFn = is.fun(propsArg) && propsArg;\n  if (propsFn && !deps) deps = [];\n  const ctrls = [];\n  const result = useSprings(length, (i, ctrl) => {\n    ctrls[i] = ctrl;\n    return getProps(propsArg, i, ctrl);\n  }, // Ensure the props function is called when no deps exist.\n  // This works around the 3 argument rule.\n  deps || [{}]);\n  useLayoutEffect(() => {\n    const reverse = is.obj(propsArg) && propsArg.reverse;\n\n    for (let i = 0; i < ctrls.length; i++) {\n      const parent = ctrls[i + (reverse ? 1 : -1)];\n      if (parent) ctrls[i].update({\n        to: parent.springs\n      }).start();\n    }\n  }, deps);\n\n  if (propsFn || arguments.length == 3) {\n    const update = result[1];\n    result[1] = useCallbackOne(propsArg => {\n      const reverse = is.obj(propsArg) && propsArg.reverse;\n      return update((i, ctrl) => {\n        const props = getProps(propsArg, i, ctrl);\n        const parent = ctrls[i + (reverse ? 1 : -1)];\n        if (parent) props.to = parent.springs;\n        return props;\n      });\n    }, deps);\n    return result;\n  }\n\n  return result[0];\n}\n\n// TODO: convert to \"const enum\" once Babel supports it\n\n/** This transition is being mounted */\nconst MOUNT = 'mount';\n/** This transition is entering or has entered */\n\nconst ENTER = 'enter';\n/** This transition had its animations updated */\n\nconst UPDATE = 'update';\n/** This transition will expire after animating */\n\nconst LEAVE = 'leave';\n\nfunction useTransition(data, props, deps) {\n  const {\n    ref,\n    reset,\n    sort,\n    trail = 0,\n    expires = true\n  } = props; // Every item has its own transition.\n\n  const items = toArray(data);\n  const transitions = []; // Keys help with reusing transitions between renders.\n  // The `key` prop can be undefined (which means the items themselves are used\n  // as keys), or a function (which maps each item to its key), or an array of\n  // keys (which are assigned to each item by index).\n\n  const keys = getKeys(items, props); // The \"onRest\" callbacks need a ref to the latest transitions.\n\n  const usedTransitions = useRef(null);\n  const prevTransitions = reset ? null : usedTransitions.current;\n  useLayoutEffect(() => {\n    usedTransitions.current = transitions;\n  }); // Destroy all transitions on dismount.\n\n  useOnce(() => () => each(usedTransitions.current, t => {\n    if (t.expired) {\n      clearTimeout(t.expirationId);\n    }\n\n    t.ctrl.dispose();\n  })); // Map old indices to new indices.\n\n  const reused = [];\n  if (prevTransitions) each(prevTransitions, (t, i) => {\n    // Expired transitions are not rendered.\n    if (t.expired) {\n      clearTimeout(t.expirationId);\n    } else {\n      i = reused[i] = keys.indexOf(t.key);\n      if (~i) transitions[i] = t;\n    }\n  }); // Mount new items with fresh transitions.\n\n  each(items, (item, i) => {\n    transitions[i] || (transitions[i] = {\n      key: keys[i],\n      item,\n      phase: MOUNT,\n      ctrl: new Controller()\n    });\n  }); // Update the item of any transition whose key still exists,\n  // and ensure leaving transitions are rendered until they finish.\n\n  if (reused.length) {\n    let i = -1;\n    each(reused, (keyIndex, prevIndex) => {\n      const t = prevTransitions[prevIndex];\n\n      if (~keyIndex) {\n        i = transitions.indexOf(t);\n        transitions[i] = _extends(_extends({}, t), {}, {\n          item: items[keyIndex]\n        });\n      } else if (props.leave) {\n        transitions.splice(++i, 0, t);\n      }\n    });\n  }\n\n  if (is.fun(sort)) {\n    transitions.sort((a, b) => sort(a.item, b.item));\n  } // Track cumulative delay for the \"trail\" prop.\n\n\n  let delay = -trail; // Expired transitions use this to dismount.\n\n  const forceUpdate = useForceUpdate(); // These props are inherited by every phase change.\n\n  const defaultProps = getDefaultProps(props); // Generate changes to apply in useEffect.\n\n  const changes = new Map();\n  each(transitions, (t, i) => {\n    const key = t.key;\n    const prevPhase = t.phase;\n    let to;\n    let phase;\n\n    if (prevPhase == MOUNT) {\n      to = props.enter;\n      phase = ENTER;\n    } else {\n      const isLeave = keys.indexOf(key) < 0;\n\n      if (prevPhase != LEAVE) {\n        if (isLeave) {\n          to = props.leave;\n          phase = LEAVE;\n        } else if (to = props.update) {\n          phase = UPDATE;\n        } else return;\n      } else if (!isLeave) {\n        to = props.enter;\n        phase = ENTER;\n      } else return;\n    } // When \"to\" is a function, it can return (1) an array of \"useSpring\" props,\n    // (2) an async function, or (3) an object with any \"useSpring\" props.\n\n\n    to = callProp(to, t.item, i);\n    to = is.obj(to) ? inferTo(to) : {\n      to\n    };\n\n    if (!to.config) {\n      const config = props.config || defaultProps.config;\n      to.config = callProp(config, t.item, i);\n    } // The payload is used to update the spring props once the current render is committed.\n\n\n    const payload = _extends(_extends({}, defaultProps), {}, {\n      delay: delay += trail,\n      // This prevents implied resets.\n      reset: false\n    }, to);\n\n    if (phase == ENTER && is.und(payload.from)) {\n      // The `initial` prop is used on the first render of our parent component,\n      // as well as when `reset: true` is passed. It overrides the `from` prop\n      // when defined, and it makes `enter` instant when null.\n      const from = is.und(props.initial) || prevTransitions ? props.from : props.initial;\n      payload.from = callProp(from, t.item, i);\n    }\n\n    const {\n      onRest\n    } = payload;\n\n    payload.onRest = result => {\n      const transitions = usedTransitions.current;\n      const t = transitions.find(t => t.key === key);\n      if (!t) return;\n\n      if (is.fun(onRest)) {\n        onRest(result, t);\n      } // Reset the phase of a cancelled enter/leave transition, so it can\n      // retry the animation on the next render.\n\n\n      if (result.cancelled && t.phase != UPDATE) {\n        t.phase = prevPhase;\n        return;\n      }\n\n      if (t.ctrl.idle) {\n        const idle = transitions.every(t => t.ctrl.idle);\n\n        if (t.phase == LEAVE) {\n          const expiry = callProp(expires, t.item);\n\n          if (expiry !== false) {\n            const expiryMs = expiry === true ? 0 : expiry;\n            t.expired = true; // Force update once the expiration delay ends.\n\n            if (!idle && expiryMs > 0) {\n              // The maximum timeout is 2^31-1\n              if (expiryMs <= 0x7fffffff) t.expirationId = setTimeout(forceUpdate, expiryMs);\n              return;\n            }\n          }\n        } // Force update once idle and expired items exist.\n\n\n        if (idle && transitions.some(t => t.expired)) {\n          forceUpdate();\n        }\n      }\n    };\n\n    const springs = getSprings(t.ctrl, payload);\n    changes.set(t, {\n      phase,\n      springs,\n      payload\n    });\n  }); // The prop overrides from an ancestor.\n\n  const context = useSpringContext(); // Merge the context into each transition.\n\n  useLayoutEffect(() => {\n    each(transitions, t => {\n      t.ctrl.start({\n        default: context\n      });\n    });\n  }, [context]);\n  const api = useMemo$1(() => {\n    return SpringHandle.create(() => {\n      return usedTransitions.current.map(t => t.ctrl);\n    });\n  }, []);\n  useImperativeHandle(ref, () => api);\n  useLayoutEffect(() => {\n    each(changes, ({\n      phase,\n      springs,\n      payload\n    }, t) => {\n      setSprings(t.ctrl, springs);\n\n      if (!context.cancel) {\n        t.phase = phase;\n\n        if (phase == ENTER) {\n          t.ctrl.start({\n            default: context\n          });\n        }\n\n        t.ctrl[ref ? 'update' : 'start'](payload);\n      }\n    });\n  }, reset ? void 0 : deps);\n\n  const renderTransitions = render => /*#__PURE__*/createElement(Fragment, null, transitions.map((t, i) => {\n    const {\n      springs\n    } = changes.get(t) || t.ctrl;\n    const elem = render(_extends({}, springs), t.item, t, i);\n    return elem && elem.type ? /*#__PURE__*/createElement(elem.type, _extends({}, elem.props, {\n      key: is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id,\n      ref: elem.ref\n    })) : elem;\n  }));\n\n  return arguments.length == 3 ? [renderTransitions, api.start, api.stop] : renderTransitions;\n}\n\nfunction getKeys(items, {\n  key,\n  keys = key\n}) {\n  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);\n}\n\n/**\n * The `Spring` component passes `SpringValue` objects to your render prop.\n */\nfunction Spring(_ref) {\n  let {\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  return children(useSpring(props));\n}\n\nfunction Trail(_ref) {\n  let {\n    items,\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"items\", \"children\"]);\n\n  const trails = useTrail(items.length, props);\n  return items.map((item, index) => {\n    const result = children(item, index);\n    return is.fun(result) ? result(trails[index]) : result;\n  });\n}\n\nfunction Transition(_ref) {\n  let {\n    items,\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"items\", \"children\"]);\n\n  return /*#__PURE__*/createElement(Fragment, null, useTransition(items, props)(children));\n}\n\n/**\n * An `Interpolation` is a memoized value that's computed whenever one of its\n * `FluidValue` dependencies has its value changed.\n *\n * Other `FrameValue` objects can depend on this. For example, passing an\n * `Interpolation` as the `to` prop of a `useSpring` call will trigger an\n * animation toward the memoized value.\n */\n\nclass Interpolation extends FrameValue {\n  /** Useful for debugging. */\n\n  /** Equals false when in the frameloop */\n\n  /** The function that maps inputs values to output */\n  constructor(source, args) {\n    super();\n    this.source = source;\n    this.key = void 0;\n    this.idle = true;\n    this.calc = void 0;\n    this.calc = createInterpolator(...args);\n\n    const value = this._get();\n\n    const nodeType = is.arr(value) ? AnimatedArray : AnimatedValue; // Assume the computed value never changes type.\n\n    setAnimated(this, nodeType.create(value));\n  }\n\n  advance(_dt) {\n    const value = this._get();\n\n    const oldValue = this.get();\n\n    if (!isEqual(value, oldValue)) {\n      getAnimated(this).setValue(value);\n\n      this._onChange(value, this.idle);\n    }\n  }\n\n  _get() {\n    const inputs = is.arr(this.source) ? this.source.map(node => node.get()) : toArray(this.source.get());\n    return this.calc(...inputs);\n  }\n\n  _reset() {\n    each(getPayload(this), node => node.reset());\n\n    super._reset();\n  }\n\n  _start() {\n    this.idle = false;\n\n    super._start();\n\n    if (skipAnimation) {\n      this.idle = true;\n      this.advance();\n    } else {\n      frameLoop.start(this);\n    }\n  }\n\n  _attach() {\n    // Start observing our \"source\" once we have an observer.\n    let idle = true;\n    let priority = 1;\n    each(toArray(this.source), source => {\n      if (isFrameValue(source)) {\n        if (!source.idle) idle = false;\n        priority = Math.max(priority, source.priority + 1);\n      }\n\n      source.addChild(this);\n    });\n    this.priority = priority;\n\n    if (!idle) {\n      this._reset();\n\n      this._start();\n    }\n  }\n\n  _detach() {\n    // Stop observing our \"source\" once we have no observers.\n    each(toArray(this.source), source => {\n      source.removeChild(this);\n    }); // This removes us from the frameloop.\n\n    this.idle = true;\n  }\n  /** @internal */\n\n\n  onParentChange(event) {\n    // Ensure our start value respects our parent values, in case\n    // any of their animations were restarted with the \"reset\" prop.\n    if (event.type == 'start') {\n      this.advance();\n    } // Change events are useful for (1) reacting to non-animated parents\n    // and (2) reacting to the last change in a parent animation.\n    else if (event.type == 'change') {\n        // If we're idle, we know for sure that this change is *not*\n        // caused by an animation.\n        if (this.idle) {\n          this.advance();\n        } // Leave the frameloop when all parents are done animating.\n        else if (event.idle) {\n            this.idle = toArray(this.source).every(source => source.idle !== false);\n\n            if (this.idle) {\n              this.advance();\n              each(getPayload(this), node => {\n                node.done = true;\n              });\n            }\n          }\n      } // Ensure our priority is greater than all parents, which means\n      // our value won't be updated until our parents have updated.\n      else if (event.type == 'priority') {\n          this.priority = toArray(this.source).reduce((max, source) => Math.max(max, (source.priority || 0) + 1), 0);\n        }\n\n    super.onParentChange(event);\n  }\n\n}\n\n/** Map the value of one or more dependencies */\n\nconst to = (source, ...args) => new Interpolation(source, args);\n/** @deprecated Use the `to` export instead */\n\nconst interpolate = (source, ...args) => (deprecateInterpolate(), new Interpolation(source, args));\n/** Extract the raw value types that are being interpolated */\n\nGlobals.assign({\n  createStringInterpolator: createStringInterpolator$1,\n  to: (source, args) => new Interpolation(source, args)\n});\n/** Advance all animations forward one frame */\n\nconst update = () => Globals.frameLoop.advance();\n\nexport { BailSignal, Controller, FrameValue, Interpolation, Spring, SpringContext, SpringHandle, SpringValue, Trail, Transition, config, inferTo, interpolate, to, update, useChain, useSpring, useSprings, useTrail, useTransition };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}